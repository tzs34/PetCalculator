/*!
 * react-flip-toolkit v6.2.2
 * MIT Licensed
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"));
	else if(typeof define === 'function' && define.amd)
		define(["react"], factory);
	else if(typeof exports === 'object')
		exports["ReactFlipToolkit"] = factory(require("react"));
	else
		root["ReactFlipToolkit"] = factory(root["React"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE__1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 5);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (false) { var throwOnDirectAccess, isValidElement, REACT_ELEMENT_TYPE; } else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = __webpack_require__(4)();
}


/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__1__;

/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: external {"root":"React","commonjs2":"react","commonjs":"react","amd":"react"}
var external_root_React_commonjs2_react_commonjs_react_amd_react_ = __webpack_require__(1);
var external_root_React_commonjs2_react_commonjs_react_amd_react_default = /*#__PURE__*/__webpack_require__.n(external_root_React_commonjs2_react_commonjs_react_amd_react_);

// EXTERNAL MODULE: ./node_modules/prop-types/index.js
var prop_types = __webpack_require__(0);
var prop_types_default = /*#__PURE__*/__webpack_require__.n(prop_types);

// CONCATENATED MODULE: ./src/flip/animateUnflippedElements/index.js
var animateUnflippedElements = function animateUnflippedElements(_ref) {
  var unflippedIds = _ref.unflippedIds,
      flipCallbacks = _ref.flipCallbacks,
      getElement = _ref.getElement,
      newFlipChildrenPositions = _ref.newFlipChildrenPositions,
      cachedFlipChildrenPositions = _ref.cachedFlipChildrenPositions,
      inProgressAnimations = _ref.inProgressAnimations;

  var enteringElements = unflippedIds.filter(function (id) {
    return newFlipChildrenPositions[id] && flipCallbacks[id];
  });

  var exitingElementIds = unflippedIds.filter(function (id) {
    return cachedFlipChildrenPositions[id] && flipCallbacks[id] && flipCallbacks[id].onExit;
  });

  var hideEnteringElements = function hideEnteringElements() {
    enteringElements.forEach(function (id) {
      if (flipCallbacks[id] && flipCallbacks[id].onAppear) {
        var element = getElement(id);
        element.style.opacity = "0";
      }
    });
  };

  var animateEnteringElements = function animateEnteringElements() {
    enteringElements.forEach(function (id, i) {
      var element = getElement(id);
      if (flipCallbacks[id] && flipCallbacks[id].onAppear) flipCallbacks[id].onAppear(element, i);
    });
  };

  var closureResolve = void 0;

  var promiseToReturn = new Promise(function (resolve, reject) {
    closureResolve = resolve;
  });

  var fragmentTuples = [];
  var exitingElementCount = 0;

  var onExitCallbacks = exitingElementIds.map(function (id, i) {
    var _cachedFlipChildrenPo = cachedFlipChildrenPositions[id].domData,
        element = _cachedFlipChildrenPo.element,
        parent = _cachedFlipChildrenPo.parent,
        _cachedFlipChildrenPo2 = _cachedFlipChildrenPo.childPosition,
        top = _cachedFlipChildrenPo2.top,
        left = _cachedFlipChildrenPo2.left,
        width = _cachedFlipChildrenPo2.width,
        height = _cachedFlipChildrenPo2.height;
    // insert back into dom

    if (getComputedStyle(parent).position === "static") {
      parent.style.position = "relative";
    }
    element.style.transform = "matrix(1, 0, 0, 1, 0, 0)";
    element.style.position = "absolute";
    element.style.top = top + "px";
    element.style.left = left + "px";
    // taken out of the dom flow, the element might have lost these dimensions
    element.style.height = height + "px";
    element.style.width = width + "px";
    var fragmentTuple = fragmentTuples.filter(function (t) {
      return t[0] === parent;
    })[0];
    if (!fragmentTuple) {
      fragmentTuple = [parent, document.createDocumentFragment()];
      fragmentTuples.push(fragmentTuple);
    }
    fragmentTuple[1].appendChild(element);

    exitingElementCount += 1;

    var stop = function stop() {
      try {
        parent.removeChild(element);
        exitingElementCount -= 1;
        if (exitingElementCount === 0) closureResolve();
      } catch (DOMException) {
        // the element is already gone
      }
    };
    inProgressAnimations[id] = { stop: stop };
    return function () {
      return flipCallbacks[id].onExit(element, i, stop);
    };
  });

  // now append all the fragments from the onExit callbacks
  // (we use fragments for performance)
  fragmentTuples.forEach(function (t) {
    var parent = t[0];
    var fragment = t[1];
    parent.appendChild(fragment);
  });

  if (!onExitCallbacks.length) closureResolve();

  var animateExitingElements = function animateExitingElements() {
    onExitCallbacks.forEach(function (c) {
      return c();
    });
    return promiseToReturn;
  };

  return {
    hideEnteringElements: hideEnteringElements,
    animateEnteringElements: animateEnteringElements,
    animateExitingElements: animateExitingElements
  };
};

/* harmony default export */ var flip_animateUnflippedElements = (animateUnflippedElements);
// CONCATENATED MODULE: ./node_modules/rematrix/dist/rematrix.es.js
/*! @license Rematrix v0.2.3

	Copyright 2018 Fisssion LLC.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
*/
/**
 * @module Rematrix
 */

/**
 * Transformation matrices in the browser come in two flavors:
 *
 *  - `matrix` using 6 values (short)
 *  - `matrix3d` using 16 values (long)
 *
 * This utility follows this [conversion guide](https://goo.gl/EJlUQ1)
 * to expand short form matrices to their equivalent long form.
 *
 * @param  {array} source - Accepts both short and long form matrices.
 * @return {array}
 */
function format(source) {
	if (source.constructor !== Array) {
		throw new TypeError('Expected array.')
	}
	if (source.length === 16) {
		return source
	}
	if (source.length === 6) {
		var matrix = identity();
		matrix[0] = source[0];
		matrix[1] = source[1];
		matrix[4] = source[2];
		matrix[5] = source[3];
		matrix[12] = source[4];
		matrix[13] = source[5];
		return matrix
	}
	throw new RangeError('Expected array with either 6 or 16 values.')
}

/**
 * Returns a matrix representing no transformation. The product of any matrix
 * multiplied by the identity matrix will be the original matrix.
 *
 * > **Tip:** Similar to how `5 * 1 === 5`, where `1` is the identity.
 *
 * @return {array}
 */
function identity() {
	var matrix = [];
	for (var i = 0; i < 16; i++) {
		i % 5 == 0 ? matrix.push(1) : matrix.push(0);
	}
	return matrix
}

/**
 * Returns a matrix describing the inverse transformation of the source
 * matrix. The product of any matrix multiplied by its inverse will be the
 * identity matrix.
 *
 * > **Tip:** Similar to how `5 * (1/5) === 1`, where `1/5` is the inverse.
 *
 * @param  {array} source - Accepts both short and long form matrices.
 * @return {array}
 */
function inverse(source) {
	var m = format(source);

	var s0 = m[0] * m[5] - m[4] * m[1];
	var s1 = m[0] * m[6] - m[4] * m[2];
	var s2 = m[0] * m[7] - m[4] * m[3];
	var s3 = m[1] * m[6] - m[5] * m[2];
	var s4 = m[1] * m[7] - m[5] * m[3];
	var s5 = m[2] * m[7] - m[6] * m[3];

	var c5 = m[10] * m[15] - m[14] * m[11];
	var c4 = m[9] * m[15] - m[13] * m[11];
	var c3 = m[9] * m[14] - m[13] * m[10];
	var c2 = m[8] * m[15] - m[12] * m[11];
	var c1 = m[8] * m[14] - m[12] * m[10];
	var c0 = m[8] * m[13] - m[12] * m[9];

	var determinant = 1 / (s0 * c5 - s1 * c4 + s2 * c3 + s3 * c2 - s4 * c1 + s5 * c0);

	if (isNaN(determinant) || determinant === Infinity) {
		throw new Error('Inverse determinant attempted to divide by zero.')
	}

	return [
		(m[5] * c5 - m[6] * c4 + m[7] * c3) * determinant,
		(-m[1] * c5 + m[2] * c4 - m[3] * c3) * determinant,
		(m[13] * s5 - m[14] * s4 + m[15] * s3) * determinant,
		(-m[9] * s5 + m[10] * s4 - m[11] * s3) * determinant,

		(-m[4] * c5 + m[6] * c2 - m[7] * c1) * determinant,
		(m[0] * c5 - m[2] * c2 + m[3] * c1) * determinant,
		(-m[12] * s5 + m[14] * s2 - m[15] * s1) * determinant,
		(m[8] * s5 - m[10] * s2 + m[11] * s1) * determinant,

		(m[4] * c4 - m[5] * c2 + m[7] * c0) * determinant,
		(-m[0] * c4 + m[1] * c2 - m[3] * c0) * determinant,
		(m[12] * s4 - m[13] * s2 + m[15] * s0) * determinant,
		(-m[8] * s4 + m[9] * s2 - m[11] * s0) * determinant,

		(-m[4] * c3 + m[5] * c1 - m[6] * c0) * determinant,
		(m[0] * c3 - m[1] * c1 + m[2] * c0) * determinant,
		(-m[12] * s3 + m[13] * s1 - m[14] * s0) * determinant,
		(m[8] * s3 - m[9] * s1 + m[10] * s0) * determinant
	]
}

/**
 * Returns a 4x4 matrix describing the combined transformations
 * of both arguments.
 *
 * > **Note:** Order is very important. For example, rotating 45°
 * along the Z-axis, followed by translating 500 pixels along the
 * Y-axis... is not the same as translating 500 pixels along the
 * Y-axis, followed by rotating 45° along on the Z-axis.
 *
 * @param  {array} m - Accepts both short and long form matrices.
 * @param  {array} x - Accepts both short and long form matrices.
 * @return {array}
 */
function multiply(m, x) {
	var fm = format(m);
	var fx = format(x);
	var product = [];

	for (var i = 0; i < 4; i++) {
		var row = [fm[i], fm[i + 4], fm[i + 8], fm[i + 12]];
		for (var j = 0; j < 4; j++) {
			var k = j * 4;
			var col = [fx[k], fx[k + 1], fx[k + 2], fx[k + 3]];
			var result =
				row[0] * col[0] + row[1] * col[1] + row[2] * col[2] + row[3] * col[3];

			product[i + k] = result;
		}
	}

	return product
}

/**
 * Attempts to return a 4x4 matrix describing the CSS transform
 * matrix passed in, but will return the identity matrix as a
 * fallback.
 *
 * **Tip:** In virtually all cases, this method is used to convert
 * a CSS matrix (retrieved as a `string` from computed styles) to
 * its equivalent array format.
 *
 * @param  {string} source - String containing a valid CSS `matrix` or `matrix3d` property.
 * @return {array}
 */
function parse(source) {
	if (typeof source === 'string') {
		var match = source.match(/matrix(3d)?\(([^)]+)\)/);
		if (match) {
			var raw = match[2].split(', ').map(parseFloat);
			return format(raw)
		}
	}
	return identity()
}

/**
 * Returns a 4x4 matrix describing Z-axis rotation.
 *
 * @param  {number} angle - Measured in degrees.
 * @return {array}
 */
function rotate(angle) {
	return rotateZ(angle)
}

/**
 * Returns a 4x4 matrix describing X-axis rotation.
 *
 * @param  {number} angle - Measured in degrees.
 * @return {array}
 */
function rotateX(angle) {
	var theta = Math.PI / 180 * angle;
	var matrix = identity();

	matrix[5] = matrix[10] = Math.cos(theta);
	matrix[6] = matrix[9] = Math.sin(theta);
	matrix[9] *= -1;

	return matrix
}

/**
 * Returns a 4x4 matrix describing Y-axis rotation.
 *
 * @param  {number} angle - Measured in degrees.
 * @return {array}
 */
function rotateY(angle) {
	var theta = Math.PI / 180 * angle;
	var matrix = identity();

	matrix[0] = matrix[10] = Math.cos(theta);
	matrix[2] = matrix[8] = Math.sin(theta);
	matrix[2] *= -1;

	return matrix
}

/**
 * Returns a 4x4 matrix describing Z-axis rotation.
 *
 * @param  {number} angle - Measured in degrees.
 * @return {array}
 */
function rotateZ(angle) {
	var theta = Math.PI / 180 * angle;
	var matrix = identity();

	matrix[0] = matrix[5] = Math.cos(theta);
	matrix[1] = matrix[4] = Math.sin(theta);
	matrix[4] *= -1;

	return matrix
}

/**
 * Returns a 4x4 matrix describing 2D scaling. The first argument
 * is used for both X and Y-axis scaling, unless an optional
 * second argument is provided to explicitly define Y-axis scaling.
 *
 * @param  {number} scalar    - Decimal multiplier.
 * @param  {number} [scalarY] - Decimal multiplier.
 * @return {array}
 */
function scale(scalar, scalarY) {
	var matrix = identity();

	matrix[0] = scalar;
	matrix[5] = typeof scalarY === 'number' ? scalarY : scalar;

	return matrix
}

/**
 * Returns a 4x4 matrix describing X-axis scaling.
 *
 * @param  {number} scalar - Decimal multiplier.
 * @return {array}
 */
function scaleX(scalar) {
	var matrix = identity();
	matrix[0] = scalar;
	return matrix
}

/**
 * Returns a 4x4 matrix describing Y-axis scaling.
 *
 * @param  {number} scalar - Decimal multiplier.
 * @return {array}
 */
function scaleY(scalar) {
	var matrix = identity();
	matrix[5] = scalar;
	return matrix
}

/**
 * Returns a 4x4 matrix describing Z-axis scaling.
 *
 * @param  {number} scalar - Decimal multiplier.
 * @return {array}
 */
function scaleZ(scalar) {
	var matrix = identity();
	matrix[10] = scalar;
	return matrix
}

/**
 * Returns a 4x4 matrix describing shear. The first argument
 * defines X-axis shearing, and an optional second argument
 * defines Y-axis shearing.
 *
 * @param  {number} angleX   - Measured in degrees.
 * @param  {number} [angleY] - Measured in degrees.
 * @return {array}
 */
function skew(angleX, angleY) {
	var thetaX = Math.PI / 180 * angleX;
	var matrix = identity();

	matrix[4] = Math.tan(thetaX);

	if (angleY) {
		var thetaY = Math.PI / 180 * angleY;
		matrix[1] = Math.tan(thetaY);
	}

	return matrix
}

/**
 * Returns a 4x4 matrix describing X-axis shear.
 *
 * @param  {number} angle - Measured in degrees.
 * @return {array}
 */
function skewX(angle) {
	var theta = Math.PI / 180 * angle;
	var matrix = identity();

	matrix[4] = Math.tan(theta);

	return matrix
}

/**
 * Returns a 4x4 matrix describing Y-axis shear.
 *
 * @param  {number} angle - Measured in degrees
 * @return {array}
 */
function skewY(angle) {
	var theta = Math.PI / 180 * angle;
	var matrix = identity();

	matrix[1] = Math.tan(theta);

	return matrix
}

/**
 * Returns a 4x4 matrix describing 2D translation. The first
 * argument defines X-axis translation, and an optional second
 * argument defines Y-axis translation.
 *
 * @param  {number} distanceX   - Measured in pixels.
 * @param  {number} [distanceY] - Measured in pixels.
 * @return {array}
 */
function translate(distanceX, distanceY) {
	var matrix = identity();
	matrix[12] = distanceX;

	if (distanceY) {
		matrix[13] = distanceY;
	}

	return matrix
}

/**
 * Returns a 4x4 matrix describing X-axis translation.
 *
 * @param  {number} distance - Measured in pixels.
 * @return {array}
 */
function translateX(distance) {
	var matrix = identity();
	matrix[12] = distance;
	return matrix
}

/**
 * Returns a 4x4 matrix describing Y-axis translation.
 *
 * @param  {number} distance - Measured in pixels.
 * @return {array}
 */
function translateY(distance) {
	var matrix = identity();
	matrix[13] = distance;
	return matrix
}

/**
 * Returns a 4x4 matrix describing Z-axis translation.
 *
 * @param  {number} distance - Measured in pixels.
 * @return {array}
 */
function translateZ(distance) {
	var matrix = identity();
	matrix[14] = distance;
	return matrix
}



// CONCATENATED MODULE: ./src/utilities.js
var isNumber = function isNumber(x) {
  return typeof x === "number";
};

var isFunction = function isFunction(x) {
  return typeof x === "function";
};

var isObject = function isObject(x) {
  return Object.prototype.toString.call(x) === "[object Object]";
};

var toArray = function toArray(arrayLike) {
  return Array.prototype.slice.apply(arrayLike);
};

var getDuplicateValsAsStrings = function getDuplicateValsAsStrings(arr) {
  var obj = arr.reduce(function (acc, curr) {
    acc[curr] = acc[curr] ? acc[curr] + 1 : 1;
    return acc;
  }, {});
  return Object.keys(obj).filter(function (val) {
    return obj[val] > 1;
  });
};

var utilities_assign = function assign(target) {
  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    args[_key - 1] = arguments[_key];
  }

  args.forEach(function (arg) {
    if (!arg) return;
    // Skip over if undefined or null
    for (var nextKey in arg) {
      // Avoid bugs when hasOwnProperty is shadowed
      if (Object.prototype.hasOwnProperty.call(arg, nextKey)) {
        target[nextKey] = arg[nextKey];
      }
    }
  });
  return target;
};
// CONCATENATED MODULE: ./src/springSettings/index.js


// adapted from
// https://github.com/chenglou/react-motion/blob/master/src/presets.js
var springSettings_springPresets = {
  noWobble: { stiffness: 200, damping: 26 },
  gentle: { stiffness: 120, damping: 14 },
  veryGentle: { stiffness: 130, damping: 17 },
  wobbly: { stiffness: 180, damping: 12 },
  stiff: { stiffness: 260, damping: 26 }
};

var springSettings_getSpringConfig = function getSpringConfig() {
  var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
      flipperSpring = _ref.flipperSpring,
      flippedSpring = _ref.flippedSpring;

  var normalizeSpring = function normalizeSpring(spring) {
    if (isObject(spring)) return spring;else if (springSettings_springPresets[spring]) return springSettings_springPresets[spring];else return {};
  };

  return utilities_assign({}, springSettings_springPresets.noWobble, normalizeSpring(flipperSpring), normalizeSpring(flippedSpring));
};
// CONCATENATED MODULE: ./src/constants.js
var DATA_FLIP_ID = "data-flip-id";
var DATA_INVERSE_FLIP_ID = "data-inverse-flip-id";
var DATA_FLIP_COMPONENT_ID = "data-flip-component-id";
var DATA_FLIP_CONFIG = "data-flip-config";
var DATA_PORTAL_KEY = "data-portal-key";
var DATA_EXIT_CONTAINER = "data-exit-container";
// CONCATENATED MODULE: ./src/flip/animateFlippedElements/filterFlipDescendants.js



// scoped selector makes sure we're querying inside the right Flipper
// container, either internally or with the right portal key
var filterFlipDescendants_selectFlipChildIds = function selectFlipChildIds(scopedSelector, selector, flippedIds) {
  var childIds = toArray(scopedSelector(selector)).map(function (el) {
    return el.dataset.flipId;
  });
  // now return an array ordered by the original order in the DOM
  return flippedIds.filter(function (id) {
    return childIds.indexOf(id) > -1;
  });
};

var filterFlipDescendants_baseSelector = "[" + DATA_FLIP_ID + "]";

/* harmony default export */ var filterFlipDescendants = (function (_ref) {
  var flipDict = _ref.flipDict,
      flippedIds = _ref.flippedIds,
      scopedSelector = _ref.scopedSelector;

  var levelToChildren = {};

  var buildHierarchy = function buildHierarchy(selector, level, oldResult) {
    var newSelector = selector + " " + filterFlipDescendants_baseSelector;
    // make sure this is scoped to the Flipper element in case there are
    // mulitiple Flipper elements on the page
    var newResult = filterFlipDescendants_selectFlipChildIds(scopedSelector, newSelector, flippedIds);

    var oldLevelChildren = oldResult.filter(function (id) {
      return newResult.indexOf(id) === -1;
    });
    levelToChildren[level] = oldLevelChildren;
    oldLevelChildren.forEach(function (childId) {
      if (flipDict[childId]) {
        flipDict[childId].level = level;
      }
    });

    if (newResult.length !== 0) buildHierarchy(newSelector, level + 1, newResult);
  };

  // the top level selectChildFlipIds should use the scopedSelector,
  buildHierarchy(filterFlipDescendants_baseSelector, 0, filterFlipDescendants_selectFlipChildIds(scopedSelector, filterFlipDescendants_baseSelector, flippedIds));

  // now make sure childIds in each flippedData contains only direct children
  // since to enable nested stagger  we want each parent to be able to kick off
  // the animations only for its direct children
  Object.keys(flipDict).forEach(function (flipId) {
    var data = flipDict[flipId];
    // scop by parent element
    data.childIds = filterFlipDescendants_selectFlipChildIds(function (selector) {
      return data.element.querySelectorAll(selector);
    }, filterFlipDescendants_baseSelector, flippedIds);

    data.childIds = data.childIds.filter(function (id) {
      return levelToChildren[data.level + 1] && levelToChildren[data.level + 1].indexOf(id) > -1;
    });
  });
  return { topLevelChildren: levelToChildren["0"] };
});
// CONCATENATED MODULE: ./src/forked-rebound/onFrame.js
/**
 *  Copyright (c) 2013, Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree. An additional grant
 *  of patent rights can be found in the PATENTS file in the same directory.
 *
 *
 */

var _onFrame = void 0;
if (typeof window !== "undefined") {
  _onFrame = window.requestAnimationFrame;
}

_onFrame = _onFrame || function (callback) {
  window.setTimeout(callback, 1000 / 60);
};

/* harmony default export */ var forked_rebound_onFrame = (_onFrame);
// CONCATENATED MODULE: ./src/forked-rebound/util.js
var util_typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 *  Copyright (c) 2013, Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree. An additional grant
 *  of patent rights can be found in the PATENTS file in the same directory.
 *
 *
 */



// Cross browser/node timer functions.
function util_onFrame(func) {
  return forked_rebound_onFrame(func);
}

var util_start = Date.now();
var util_performanceNow = (typeof performance === "undefined" ? "undefined" : util_typeof(performance)) === "object" && typeof performance.now === "function" ? function () {
  return performance.now();
} : function () {
  return Date.now() - util_start;
};

// Lop off the first occurence of the reference in the Array.
function util_removeFirst(array, item) {
  var idx = array.indexOf(item);
  idx !== -1 && array.splice(idx, 1);
}
// CONCATENATED MODULE: ./src/forked-rebound/Loopers.js
function Loopers_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *  Copyright (c) 2013, Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree. An additional grant
 *  of patent rights can be found in the PATENTS file in the same directory.
 *
 *
 */



/**
 * Plays each frame of the SpringSystem on animation
 * timing loop. This is the default type of looper for a new spring system
 * as it is the most common when developing UI.
 * @public
 */
var Loopers_AnimationLooper = function () {
  function AnimationLooper() {
    Loopers_classCallCheck(this, AnimationLooper);
  }

  AnimationLooper.prototype.run = function run() {
    var _this = this;

    util_onFrame(function () {
      _this.springSystem.loop(util_performanceNow());
    });
  };

  return AnimationLooper;
}();
// CONCATENATED MODULE: ./src/forked-rebound/Spring.js
function Spring_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 *  Copyright (c) 2013, Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree. An additional grant
 *  of patent rights can be found in the PATENTS file in the same directory.
 *
 *
 */



var Spring_PhysicsState = function PhysicsState() {
  Spring_classCallCheck(this, PhysicsState);

  this.position = 0;
  this.velocity = 0;
};

/**
 * Provides a model of a classical spring acting to
 * resolve a body to equilibrium. Springs have configurable
 * tension which is a force multipler on the displacement of the
 * spring from its rest point or `endValue` as defined by [Hooke's
 * law](http://en.wikipedia.org/wiki/Hooke's_law). Springs also have
 * configurable friction, which ensures that they do not oscillate
 * infinitely. When a Spring is displaced by updating it's resting
 * or `currentValue`, the SpringSystems that contain that Spring
 * will automatically start looping to solve for equilibrium. As each
 * timestep passes, `SpringListener` objects attached to the Spring
 * will be notified of the updates providing a way to drive an
 * animation off of the spring's resolution curve.
 * @public
 */


var Spring_Spring = function () {
  function Spring(springSystem) {
    Spring_classCallCheck(this, Spring);

    this._id = "s" + Spring._ID++;
    this._springSystem = springSystem;

    this.listeners = [];
    this._startValue = 0;

    this._currentState = new Spring_PhysicsState();
    this._displacementFromRestThreshold = 0.001;
    this._endValue = 0;
    this._overshootClampingEnabled = false;
    this._previousState = new Spring_PhysicsState();
    this._restSpeedThreshold = 0.001;

    this._tempState = new Spring_PhysicsState();
    this._timeAccumulator = 0;
    this._wasAtRest = true;
  }

  Spring.prototype.getId = function getId() {
    return this._id;
  };

  /**
   * Remove a Spring from simulation and clear its listeners.
   * @public
   */


  Spring.prototype.destroy = function destroy() {
    this.listeners = [];
    this._springSystem.deregisterSpring(this);
  };

  /**
   * Set the configuration values for this Spring. A SpringConfig
   * contains the tension and friction values used to solve for the
   * equilibrium of the Spring in the physics loop.
   * @public
   */


  Spring.prototype.setSpringConfig = function setSpringConfig(springConfig) {
    this._springConfig = springConfig;
    return this;
  };
  /**
   * Retrieve the current value of the Spring.
   * @public
   */


  Spring.prototype.getCurrentValue = function getCurrentValue() {
    return this._currentState.position;
  };

  /**
   * Get the absolute distance of the Spring from a given state value
   */


  Spring.prototype.getDisplacementDistanceForState = function getDisplacementDistanceForState(state) {
    return Math.abs(this._endValue - state.position);
  };

  /**
   * Set the endValue or resting position of the spring. If this
   * value is different than the current value, the SpringSystem will
   * be notified and will begin running its solver loop to resolve
   * the Spring to equilibrium. Any listeners that are registered
   * for onSpringEndStateChange will also be notified of this update
   * immediately.
   * @public
   */


  Spring.prototype.setEndValue = function setEndValue(endValue) {
    if (this._endValue === endValue && this.isAtRest()) {
      return this;
    }
    this._startValue = this.getCurrentValue();
    this._endValue = endValue;
    this._springSystem.activateSpring(this.getId());
    for (var i = 0, len = this.listeners.length; i < len; i++) {
      var listener = this.listeners[i];
      var onChange = listener.onSpringEndStateChange;
      onChange && onChange(this);
    }
    return this;
  };

  /**
   * Set the current velocity of the Spring, in pixels per second. As
   * previously mentioned, this can be useful when you are performing
   * a direct manipulation gesture. When a UI element is released you
   * may call setVelocity on its animation Spring so that the Spring
   * continues with the same velocity as the gesture ended with. The
   * friction, tension, and displacement of the Spring will then
   * govern its motion to return to rest on a natural feeling curve.
   * @public
   */


  Spring.prototype.setVelocity = function setVelocity(velocity) {
    if (velocity === this._currentState.velocity) {
      return this;
    }
    this._currentState.velocity = velocity;
    this._springSystem.activateSpring(this.getId());
    return this;
  };

  /**
   * Enable overshoot clamping. This means that the Spring will stop
   * immediately when it reaches its resting position regardless of
   * any existing momentum it may have. This can be useful for certain
   * types of animations that should not oscillate such as a scale
   * down to 0 or alpha fade.
   * @public
   */


  Spring.prototype.setOvershootClampingEnabled = function setOvershootClampingEnabled(enabled) {
    this._overshootClampingEnabled = enabled;
    return this;
  };

  /**
   * Check if the Spring has gone past its end point by comparing
   * the direction it was moving in when it started to the current
   * position and end value.
   * @public
   */


  Spring.prototype.isOvershooting = function isOvershooting() {
    var start = this._startValue;
    var end = this._endValue;
    return this._springConfig.tension > 0 && (start < end && this.getCurrentValue() > end || start > end && this.getCurrentValue() < end);
  };

  /**
   * The main solver method for the Spring. It takes
   * the current time and delta since the last time step and performs
   * an RK4 integration to get the new position and velocity state
   * for the Spring based on the tension, friction, velocity, and
   * displacement of the Spring.
   * @public
   */


  Spring.prototype.advance = function advance(time, realDeltaTime) {
    var isAtRest = this.isAtRest();

    if (isAtRest && this._wasAtRest) {
      return;
    }

    var adjustedDeltaTime = realDeltaTime;
    if (realDeltaTime > Spring.MAX_DELTA_TIME_SEC) {
      adjustedDeltaTime = Spring.MAX_DELTA_TIME_SEC;
    }

    this._timeAccumulator += adjustedDeltaTime;

    var tension = this._springConfig.tension;
    var friction = this._springConfig.friction;
    var position = this._currentState.position;
    var velocity = this._currentState.velocity;
    var tempPosition = this._tempState.position;
    var tempVelocity = this._tempState.velocity;
    var aVelocity = void 0;
    var aAcceleration = void 0;
    var bVelocity = void 0;
    var bAcceleration = void 0;
    var cVelocity = void 0;
    var cAcceleration = void 0;
    var dVelocity = void 0;
    var dAcceleration = void 0;
    var dxdt = void 0;
    var dvdt = void 0;

    while (this._timeAccumulator >= Spring.SOLVER_TIMESTEP_SEC) {
      this._timeAccumulator -= Spring.SOLVER_TIMESTEP_SEC;

      if (this._timeAccumulator < Spring.SOLVER_TIMESTEP_SEC) {
        this._previousState.position = position;
        this._previousState.velocity = velocity;
      }

      aVelocity = velocity;
      aAcceleration = tension * (this._endValue - tempPosition) - friction * velocity;

      tempPosition = position + aVelocity * Spring.SOLVER_TIMESTEP_SEC * 0.5;
      tempVelocity = velocity + aAcceleration * Spring.SOLVER_TIMESTEP_SEC * 0.5;
      bVelocity = tempVelocity;
      bAcceleration = tension * (this._endValue - tempPosition) - friction * tempVelocity;

      tempPosition = position + bVelocity * Spring.SOLVER_TIMESTEP_SEC * 0.5;
      tempVelocity = velocity + bAcceleration * Spring.SOLVER_TIMESTEP_SEC * 0.5;
      cVelocity = tempVelocity;
      cAcceleration = tension * (this._endValue - tempPosition) - friction * tempVelocity;

      tempPosition = position + cVelocity * Spring.SOLVER_TIMESTEP_SEC;
      tempVelocity = velocity + cAcceleration * Spring.SOLVER_TIMESTEP_SEC;
      dVelocity = tempVelocity;
      dAcceleration = tension * (this._endValue - tempPosition) - friction * tempVelocity;

      dxdt = 1.0 / 6.0 * (aVelocity + 2.0 * (bVelocity + cVelocity) + dVelocity);
      dvdt = 1.0 / 6.0 * (aAcceleration + 2.0 * (bAcceleration + cAcceleration) + dAcceleration);

      position += dxdt * Spring.SOLVER_TIMESTEP_SEC;
      velocity += dvdt * Spring.SOLVER_TIMESTEP_SEC;
    }

    this._tempState.position = tempPosition;
    this._tempState.velocity = tempVelocity;

    this._currentState.position = position;
    this._currentState.velocity = velocity;

    if (this._timeAccumulator > 0) {
      this._interpolate(this._timeAccumulator / Spring.SOLVER_TIMESTEP_SEC);
    }

    if (this.isAtRest() || this._overshootClampingEnabled && this.isOvershooting()) {
      if (this._springConfig.tension > 0) {
        this._startValue = this._endValue;
        this._currentState.position = this._endValue;
      } else {
        this._endValue = this._currentState.position;
        this._startValue = this._endValue;
      }
      this.setVelocity(0);
      isAtRest = true;
    }

    var notifyActivate = false;
    if (this._wasAtRest) {
      this._wasAtRest = false;
      notifyActivate = true;
    }

    var notifyAtRest = false;
    if (isAtRest) {
      this._wasAtRest = true;
      notifyAtRest = true;
    }

    this.notifyPositionUpdated(notifyActivate, notifyAtRest);
  };

  Spring.prototype.notifyPositionUpdated = function notifyPositionUpdated(notifyActivate, notifyAtRest) {
    for (var i = 0, len = this.listeners.length; i < len; i++) {
      var listener = this.listeners[i];

      if (notifyActivate && listener.onSpringActivate) {
        listener.onSpringActivate(this);
      }

      if (listener.onSpringUpdate) {
        listener.onSpringUpdate(this);
      }

      if (notifyAtRest && listener.onSpringAtRest) {
        listener.onSpringAtRest(this);
      }
    }
  };

  /**
   * Check if the SpringSystem should advance. Springs are advanced
   * a final frame after they reach equilibrium to ensure that the
   * currentValue is exactly the requested endValue regardless of the
   * displacement threshold.
   * @public
   */


  Spring.prototype.systemShouldAdvance = function systemShouldAdvance() {
    return !this.isAtRest() || !this.wasAtRest();
  };

  Spring.prototype.wasAtRest = function wasAtRest() {
    return this._wasAtRest;
  };

  /**
   * Check if the Spring is atRest meaning that it's currentValue and
   * endValue are the same and that it has no velocity. The previously
   * described thresholds for speed and displacement define the bounds
   * of this equivalence check. If the Spring has 0 tension, then it will
   * be considered at rest whenever its absolute velocity drops below the
   * restSpeedThreshold.
   * @public
   */


  Spring.prototype.isAtRest = function isAtRest() {
    return Math.abs(this._currentState.velocity) < this._restSpeedThreshold && (this.getDisplacementDistanceForState(this._currentState) <= this._displacementFromRestThreshold || this._springConfig.tension === 0);
  };

  Spring.prototype._interpolate = function _interpolate(alpha) {
    this._currentState.position = this._currentState.position * alpha + this._previousState.position * (1 - alpha);
    this._currentState.velocity = this._currentState.velocity * alpha + this._previousState.velocity * (1 - alpha);
  };

  Spring.prototype.addListener = function addListener(newListener) {
    this.listeners.push(newListener);
    return this;
  };

  Spring.prototype.removeListener = function removeListener(listenerToRemove) {
    util_removeFirst(this.listeners, listenerToRemove);
    return this;
  };

  return Spring;
}();

Spring_Spring._ID = 0;
Spring_Spring.MAX_DELTA_TIME_SEC = 0.064;
Spring_Spring.SOLVER_TIMESTEP_SEC = 0.001;

/* harmony default export */ var forked_rebound_Spring = (Spring_Spring);
// CONCATENATED MODULE: ./src/forked-rebound/SpringSystem.js
function SpringSystem_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

//
/**
 *  Copyright (c) 2013, Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree. An additional grant
 *  of patent rights can be found in the PATENTS file in the same directory.
 *
 */





/**
 * A set of Springs that all run on the same physics
 * timing loop. To get started with a Rebound animation, first
 * create a new SpringSystem and then add springs to it.
 * @public
 */

var SpringSystem_SpringSystem = function () {
  function SpringSystem(looper) {
    SpringSystem_classCallCheck(this, SpringSystem);

    this.looper = looper || new Loopers_AnimationLooper();
    this.looper.springSystem = this;

    this.listeners = [];
    this._activeSprings = [];
    this._idleSpringIndices = [];
    this._isIdle = true;
    this._lastTimeMillis = -1;
    this._springRegistry = {};
  }

  /**
   * Add a new spring to this SpringSystem. This Spring will now be solved for
   * during the physics iteration loop. By default the spring will use the
   * default Origami spring config with 40 tension and 7 friction, but you can
   * also provide your own values here.
   * @public
   */


  SpringSystem.prototype.createSpring = function createSpring(tension, friction) {
    return this.createSpringWithConfig({ tension: tension, friction: friction });
  };
  /**
   * Add a spring with the provided SpringConfig.
   * @public
   */


  SpringSystem.prototype.createSpringWithConfig = function createSpringWithConfig(springConfig) {
    var spring = new forked_rebound_Spring(this);
    this.registerSpring(spring);
    spring.setSpringConfig(springConfig);
    return spring;
  };

  /**
   * Check if a SpringSystem is idle or active. If all of the Springs in the
   * SpringSystem are at rest, i.e. the physics forces have reached equilibrium,
   * then this method will return true.
   * @public
   */


  SpringSystem.prototype.getIsIdle = function getIsIdle() {
    return this._isIdle;
  };

  /**
   * Manually add a spring to this system. This is called automatically
   * if a Spring is created with SpringSystem#createSpring.
   *
   * This method sets the spring up in the registry so that it can be solved
   * in the solver loop.
   * @public
   */


  SpringSystem.prototype.registerSpring = function registerSpring(spring) {
    this._springRegistry[spring.getId()] = spring;
  };

  /**
   * Deregister a spring with this SpringSystem. The SpringSystem will
   * no longer consider this Spring during its integration loop once
   * this is called. This is normally done automatically for you when
   * you call Spring#destroy.
   * @public
   */


  SpringSystem.prototype.deregisterSpring = function deregisterSpring(spring) {
    util_removeFirst(this._activeSprings, spring);
    delete this._springRegistry[spring.getId()];
  };

  SpringSystem.prototype.advance = function advance(time, deltaTime) {
    while (this._idleSpringIndices.length > 0) {
      this._idleSpringIndices.pop();
    }
    for (var i = 0, len = this._activeSprings.length; i < len; i++) {
      var spring = this._activeSprings[i];
      // note from alex: had to add this otherwise deleting springs caused errors
      if (!spring) return;
      if (spring.systemShouldAdvance()) {
        spring.advance(time / 1000.0, deltaTime / 1000.0);
      } else {
        this._idleSpringIndices.push(this._activeSprings.indexOf(spring));
      }
    }
    while (this._idleSpringIndices.length > 0) {
      var idx = this._idleSpringIndices.pop();
      idx >= 0 && this._activeSprings.splice(idx, 1);
    }
  };

  /**
   * This is the main solver loop called to move the simulation
   * forward through time. Before each pass in the solver loop
   * onBeforeIntegrate is called on an any listeners that have
   * registered themeselves with the SpringSystem. This gives you
   * an opportunity to apply any constraints or adjustments to
   * the springs that should be enforced before each iteration
   * loop. Next the advance method is called to move each Spring in
   * the systemShouldAdvance forward to the current time. After the
   * integration step runs in advance, onAfterIntegrate is called
   * on any listeners that have registered themselves with the
   * SpringSystem. This gives you an opportunity to run any post
   * integration constraints or adjustments on the Springs in the
   * SpringSystem.
   * @public
   */


  SpringSystem.prototype.loop = function loop(currentTimeMillis) {
    var listener = void 0;
    if (this._lastTimeMillis === -1) {
      this._lastTimeMillis = currentTimeMillis - 1;
    }
    var ellapsedMillis = currentTimeMillis - this._lastTimeMillis;
    this._lastTimeMillis = currentTimeMillis;

    var i = 0;
    var len = this.listeners.length;
    for (i = 0; i < len; i++) {
      listener = this.listeners[i];
      listener.onBeforeIntegrate && listener.onBeforeIntegrate(this);
    }

    this.advance(currentTimeMillis, ellapsedMillis);
    if (this._activeSprings.length === 0) {
      this._isIdle = true;
      this._lastTimeMillis = -1;
    }

    for (i = 0; i < len; i++) {
      listener = this.listeners[i];
      listener.onAfterIntegrate && listener.onAfterIntegrate(this);
    }

    if (!this._isIdle) {
      this.looper.run();
    }
  };

  /**
   * Used to notify the SpringSystem that a Spring has become displaced.
   * The system responds by starting its solver loop up if it is currently idle.
   */


  SpringSystem.prototype.activateSpring = function activateSpring(springId) {
    var spring = this._springRegistry[springId];
    if (this._activeSprings.indexOf(spring) === -1) {
      this._activeSprings.push(spring);
    }
    if (this.getIsIdle()) {
      this._isIdle = false;
      this.looper.run();
    }
  };

  return SpringSystem;
}();

/* harmony default export */ var forked_rebound_SpringSystem = (SpringSystem_SpringSystem);
// CONCATENATED MODULE: ./src/forked-rebound/index.js
/**
 *  Copyright (c) 2013, Facebook, Inc.
 *  All rights reserved.
 *
 *  This source code is licensed under the BSD-style license found in the
 *  LICENSE file in the root directory of this source tree. An additional grant
 *  of patent rights can be found in the PATENTS file in the same directory.
 *
 *      
 */



// CONCATENATED MODULE: ./src/flip/animateFlippedElements/spring.js


// this should get created only 1x
var spring_springSystem = new forked_rebound_SpringSystem();

var spring_createSuspendedSpring = function createSuspendedSpring(_ref) {
  var _ref$springConfig = _ref.springConfig,
      stiffness = _ref$springConfig.stiffness,
      damping = _ref$springConfig.damping,
      overshootClamping = _ref$springConfig.overshootClamping,
      noOp = _ref.noOp,
      onSpringActivate = _ref.onSpringActivate,
      getOnUpdateFunc = _ref.getOnUpdateFunc,
      onAnimationEnd = _ref.onAnimationEnd;

  if (noOp) return;
  var spring = spring_springSystem.createSpring(stiffness, damping);
  spring.setOvershootClampingEnabled(!!overshootClamping);
  spring.addListener({
    onSpringActivate: onSpringActivate,
    onSpringUpdate: getOnUpdateFunc(spring.destroy.bind(spring)),
    onSpringAtRest: function onSpringAtRest() {
      // prevent SpringSystem from caching unused springs
      spring.destroy();
      onAnimationEnd();
    }
  });
  return spring;
};

var spring_createSpring = function createSpring(flipped) {
  var spring = spring_createSuspendedSpring(flipped);
  if (spring) spring.setEndValue(1);else {
    // even if it was a noop,
    // we still need to call onSpringActivate in case it calls
    // cascading flip initiation functions
    flipped.onSpringActivate();
  }
};

var spring_staggeredSprings = function staggeredSprings(flippedArray) {
  var staggerConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!flippedArray || !flippedArray.length) return;

  if (staggerConfig.reverse) flippedArray.reverse();

  var normalizedSpeed = staggerConfig.speed ? 1 + Math.max(Math.min(staggerConfig.speed, 0), 1) : 1.1;

  var nextThreshold = 1 / Math.max(Math.min(flippedArray.length, 100), 10);

  var springFuncs = flippedArray.filter(function (flipped) {
    return !flipped.noOp;
  }).map(function (flipped, i) {
    var cachedGetOnUpdate = flipped.getOnUpdateFunc;

    // modify the update function to adjust
    // the end value of the trailing Flipped component
    flipped.getOnUpdateFunc = function (stop) {
      var onUpdate = cachedGetOnUpdate(stop);
      return function (spring) {
        var currentValue = spring.getCurrentValue();
        if (currentValue > nextThreshold) {
          springFuncs[i + 1] && springFuncs[i + 1].setEndValue(Math.min(currentValue * normalizedSpeed, 1));
        }
        // now call the actual update function
        onUpdate(spring);
      };
    };
    return flipped;
  }).map(function (flipped) {
    return spring_createSuspendedSpring(flipped);
  });

  springFuncs[0] && springFuncs[0].setEndValue(1);
};
// CONCATENATED MODULE: ./src/flip/animateFlippedElements/initiateAnimations.js


var initiateAnimations_initiateImmediateAnimations = function initiateImmediateAnimations(immediate) {
  if (!immediate) return;
  immediate.forEach(function (flipped) {
    spring_createSpring(flipped);
    initiateImmediateAnimations(flipped.immediate);
  });
};

var initiateAnimations_createCallTree = function createCallTree(_ref) {
  var flipDict = _ref.flipDict,
      topLevelChildren = _ref.topLevelChildren,
      initiateStaggeredAnimations = _ref.initiateStaggeredAnimations;

  //build a data struct to run the springs
  var tree = {
    root: {
      staggeredChildren: {},
      immediateChildren: []
    }

    // helper function to build the nested structure
  };var appendChild = function appendChild(parent, childId) {
    var flipData = flipDict[childId];
    // might have been filtered (e.g. because it was off screen)
    if (!flipData) return;

    if (flipData.stagger) {
      parent.staggeredChildren[flipData.stagger] ? parent.staggeredChildren[flipData.stagger].push(flipData) : parent.staggeredChildren[flipData.stagger] = [flipData];
    } else parent.immediateChildren.push(flipData);

    // only when the spring is first activated, activate the child animations as well
    // this enables nested stagger
    flipData.onSpringActivate = function () {
      initiateAnimations_initiateImmediateAnimations(flipData.immediateChildren);
      initiateStaggeredAnimations(flipData.staggeredChildren);
    };

    flipData.staggeredChildren = {};
    flipData.immediateChildren = [];

    flipData.childIds.forEach(function (childId) {
      return appendChild(flipData, childId);
    });
  };

  // create the nested structure
  topLevelChildren.forEach(function (c) {
    appendChild(tree.root, c);
  });

  return tree;
};

/* harmony default export */ var initiateAnimations = (function (_ref2) {
  var staggerConfig = _ref2.staggerConfig,
      flipDict = _ref2.flipDict,
      topLevelChildren = _ref2.topLevelChildren;

  var initiateStaggeredAnimations = function initiateStaggeredAnimations(staggered) {
    if (!staggered || !Object.keys(staggered).length) return;
    Object.keys(staggered).forEach(function (staggerKey) {
      return spring_staggeredSprings(staggered[staggerKey], staggerConfig[staggerKey]);
    });
  };

  var tree = initiateAnimations_createCallTree({
    flipDict: flipDict,
    topLevelChildren: topLevelChildren,
    initiateStaggeredAnimations: initiateStaggeredAnimations
  });

  initiateAnimations_initiateImmediateAnimations(tree.root.immediateChildren);
  initiateStaggeredAnimations(tree.root.staggeredChildren);
});
// CONCATENATED MODULE: ./src/flip/animateFlippedElements/index.js







// 3d transforms were causing weird issues in chrome,
// especially when opacity was also being tweened,
// so convert to a 2d matrix
var animateFlippedElements_convertMatrix3dArrayTo2dArray = function convertMatrix3dArrayTo2dArray(matrix) {
  return [0, 1, 4, 5, 12, 13].map(function (index) {
    return matrix[index];
  });
};

var animateFlippedElements_convertMatrix2dArrayToString = function convertMatrix2dArrayToString(matrix) {
  return "matrix(" + matrix.join(", ") + ")";
};

var animateFlippedElements_invertTransformsForChildren = function invertTransformsForChildren(_ref) {
  var invertedChildren = _ref.invertedChildren,
      matrix = _ref.matrix,
      body = _ref.body;

  invertedChildren.forEach(function (_ref2) {
    var child = _ref2[0],
        childFlipConfig = _ref2[1];

    if (!body.contains(child)) {
      return;
    }
    var scaleX = matrix[0];
    var scaleY = matrix[3];
    var translateX = matrix[4];
    var translateY = matrix[5];

    var inverseVals = { translateX: 0, translateY: 0, scaleX: 1, scaleY: 1 };
    var transformString = "";
    if (childFlipConfig.translate) {
      inverseVals.translateX = -translateX / scaleX;
      inverseVals.translateY = -translateY / scaleY;
      transformString += "translate(" + inverseVals.translateX + "px, " + inverseVals.translateY + "px)";
    }
    if (childFlipConfig.scale) {
      inverseVals.scaleX = 1 / scaleX;
      inverseVals.scaleY = 1 / scaleY;
      transformString += " scale(" + inverseVals.scaleX + ", " + inverseVals.scaleY + ")";
    }
    child.style.transform = transformString;
  });
};

var animateFlippedElements_createApplyStylesFunc = function createApplyStylesFunc(_ref3) {
  var element = _ref3.element,
      invertedChildren = _ref3.invertedChildren,
      body = _ref3.body;
  return function (_ref4) {
    var matrix = _ref4.matrix,
        opacity = _ref4.opacity,
        forceMinVals = _ref4.forceMinVals;

    if (isNumber(opacity)) {
      element.style.opacity = opacity;
    }

    if (forceMinVals) {
      element.style.minHeight = "1px";
      element.style.minWidth = "1px";
    }

    if (!matrix) return;
    var stringTransform = animateFlippedElements_convertMatrix2dArrayToString(matrix);

    // keep a tiny, invisible rotateZ transform on the element to try to
    // prevent Chrome from pixel-snapping when scale transforms
    // are removed
    stringTransform = stringTransform === "matrix(1, 0, 0, 1, 0, 0)" ? "matrix(1, 0.0001, -0.0001, 1, 0, 0)" : stringTransform;
    element.style.transform = stringTransform;

    if (invertedChildren) {
      animateFlippedElements_invertTransformsForChildren({
        invertedChildren: invertedChildren,
        matrix: matrix,
        body: body
      });
    }
  };
};

var animateFlippedElements_rectInViewport = function rectInViewport(_ref5) {
  var top = _ref5.top,
      bottom = _ref5.bottom,
      left = _ref5.left,
      right = _ref5.right;

  return top < window.innerHeight && bottom > 0 && left < window.innerWidth && right > 0;
};

var animateFlippedElements_getInvertedChildren = function getInvertedChildren(element, id) {
  return toArray(element.querySelectorAll("[" + DATA_INVERSE_FLIP_ID + "=\"" + id + "\"]"));
};

var animateFlippedElements_tweenProp = function tweenProp(start, end, position) {
  return start + (end - start) * position;
};

var animateFlippedElements_animateFlippedElements = function animateFlippedElements(_ref6) {
  var flippedIds = _ref6.flippedIds,
      flipCallbacks = _ref6.flipCallbacks,
      inProgressAnimations = _ref6.inProgressAnimations,
      cachedFlipChildrenPositions = _ref6.cachedFlipChildrenPositions,
      newFlipChildrenPositions = _ref6.newFlipChildrenPositions,
      applyTransformOrigin = _ref6.applyTransformOrigin,
      spring = _ref6.spring,
      getElement = _ref6.getElement,
      debug = _ref6.debug,
      staggerConfig = _ref6.staggerConfig,
      decisionData = _ref6.decisionData,
      scopedSelector = _ref6.scopedSelector;

  var body = document.querySelector("body");

  // the stuff below is used so we can return a promise that resolves when all FLIP animations have
  // completed
  var closureResolve = void 0;
  var flipCompletedPromise = new Promise(function (resolve, reject) {
    closureResolve = resolve;
  });
  var withInitFuncs = void 0;
  var completedAnimationIds = [];

  if (debug) {
    // eslint-disable-next-line no-console
    console.error('[react-flip-toolkit]\nThe "debug" prop is set to true. All FLIP animations will return at the beginning of the transition.');
  }

  var duplicateFlipIds = getDuplicateValsAsStrings(flippedIds);
  if (duplicateFlipIds.length) {
    // eslint-disable-next-line no-console
    console.error("[react-flip-toolkit]\nThere are currently multiple elements with the same flipId on the page.\nThe animation will only work if each Flipped component has a unique flipId.\nDuplicate flipId" + (duplicateFlipIds.length > 1 ? "s" : "") + ": " + duplicateFlipIds.join("\n"));
  }

  var flipDataArray = flippedIds
  // take all the measurements we need
  // and return an object with animation functions + necessary data
  .map(function (id) {
    var prevRect = cachedFlipChildrenPositions[id].rect;
    var currentRect = newFlipChildrenPositions[id].rect;
    var prevOpacity = cachedFlipChildrenPositions[id].opacity;
    var currentOpacity = newFlipChildrenPositions[id].opacity;
    var needsForcedMinVals = currentRect.width < 1 || currentRect.height < 1;

    // don't animate elements outside of the user's viewport
    if (!animateFlippedElements_rectInViewport(prevRect) && !animateFlippedElements_rectInViewport(currentRect)) {
      return false;
    }
    // it's never going to be visible, so dont animate it
    if (prevRect.width === 0 && currentRect.width === 0 || prevRect.height === 0 && currentRect.height === 0) {
      return false;
    }

    var element = getElement(id);

    // this might happen if we are rapidly adding & removing elements(?)
    if (!element) return false;

    var flipConfig = JSON.parse(element.dataset.flipConfig);

    var springConfig = springSettings_getSpringConfig({
      flipperSpring: spring,
      flippedSpring: flipConfig.spring
    });

    var stagger = flipConfig.stagger === true ? "default" : flipConfig.stagger;

    var toReturn = {
      element: element,
      id: id,
      stagger: stagger,
      springConfig: springConfig,
      noOp: true
    };

    if (flipCallbacks[id] && flipCallbacks[id].shouldFlip) {
      var elementShouldFlip = flipCallbacks[id].shouldFlip(decisionData.prev, decisionData.current);
      // this element wont be animated, but its children might be
      if (!elementShouldFlip) return toReturn;
    }

    // don't animate elements that didn't change
    // but we might want to animate children
    if (prevRect.left === currentRect.left && prevRect.top === currentRect.top && prevRect.width === currentRect.width && prevRect.height === currentRect.height && prevOpacity === currentOpacity) {
      // this element wont be animated, but its children might be
      return toReturn;
    }

    toReturn.noOp = false;

    var currentTransform = parse(newFlipChildrenPositions[id].transform);

    var toVals = { matrix: currentTransform };

    var fromVals = {};
    var transformsArray = [currentTransform];

    // we're only going to animate the values that the child wants animated
    if (flipConfig.translate) {
      transformsArray.push(translateX(prevRect.left - currentRect.left));
      transformsArray.push(translateY(prevRect.top - currentRect.top));
    }
    // going any smaller than 1px breaks transitions in Chrome
    if (flipConfig.scale) {
      transformsArray.push(scaleX(Math.max(prevRect.width, 1) / Math.max(currentRect.width, 1)));
      transformsArray.push(scaleY(Math.max(prevRect.height, 1) / Math.max(currentRect.height, 1)));
    }

    if (flipConfig.opacity) {
      fromVals.opacity = prevOpacity;
      toVals.opacity = currentOpacity;
    }

    var invertedChildren = [];

    if (!flipCallbacks[id] || !flipCallbacks[id].shouldInvert || flipCallbacks[id].shouldInvert(decisionData.prev, decisionData.current)) {
      invertedChildren = animateFlippedElements_getInvertedChildren(element, id).map(function (c) {
        return [c, JSON.parse(c.dataset.flipConfig)];
      });
    }

    fromVals.matrix = animateFlippedElements_convertMatrix3dArrayTo2dArray(transformsArray.reduce(multiply));

    toVals.matrix = animateFlippedElements_convertMatrix3dArrayTo2dArray(toVals.matrix);

    var applyStyles = animateFlippedElements_createApplyStylesFunc({
      element: element,
      invertedChildren: invertedChildren,
      body: body
    });

    var onComplete = void 0;
    if (flipCallbacks[id] && flipCallbacks[id].onComplete) {
      // must cache or else this could cause an error
      var cachedOnComplete = flipCallbacks[id].onComplete;
      onComplete = function onComplete() {
        return cachedOnComplete(element, decisionData.prev, decisionData.current);
      };
    }

    // this should be called when animation ends naturally
    // but also when it is interrupted
    // when it is called, the animation has already been cancelled
    var onAnimationEnd = function onAnimationEnd() {
      delete inProgressAnimations[id];
      isFunction(onComplete) && onComplete();
      if (needsForcedMinVals && element) {
        element.style.minHeight = "";
        element.style.minWidth = "";
      }
      completedAnimationIds.push(id);

      if (completedAnimationIds.length >= withInitFuncs.length) {
        // we can theoretically call multiple times since a promise only resolves 1x
        // but that shouldnt happen
        closureResolve();
      }
    };

    var animateOpacity = isNumber(fromVals.opacity) && fromVals.opacity !== toVals.opacity;

    var onStartCalled = false;

    var getOnUpdateFunc = function getOnUpdateFunc(stop) {
      inProgressAnimations[id] = {
        stop: stop,
        onComplete: onComplete
      };
      return function (spring) {
        //trigger the user provided onStart function
        if (!onStartCalled) {
          onStartCalled = true;
          if (flipCallbacks[id] && flipCallbacks[id].onStart) flipCallbacks[id].onStart(element, decisionData.prev, decisionData.current);
        }

        var currentValue = spring.getCurrentValue();

        if (!body.contains(element)) {
          stop();
          return;
        }

        var vals = {};

        vals.matrix = fromVals.matrix.map(function (fromVal, index) {
          return animateFlippedElements_tweenProp(fromVal, toVals.matrix[index], currentValue);
        });

        if (animateOpacity) {
          vals.opacity = animateFlippedElements_tweenProp(fromVals.opacity, toVals.opacity, currentValue);
        }
        applyStyles(vals);
      };
    };

    var initializeFlip = function initializeFlip() {
      // before animating, immediately apply FLIP styles to prevent flicker
      applyStyles({
        matrix: fromVals.matrix,
        opacity: animateOpacity && fromVals.opacity,
        forceMinVals: needsForcedMinVals
      });
      // and batch any other style updates if necessary
      if (flipConfig.transformOrigin) {
        element.style.transformOrigin = flipConfig.transformOrigin;
      } else if (applyTransformOrigin) {
        element.style.transformOrigin = "0 0";
      }

      invertedChildren.forEach(function (_ref7) {
        var child = _ref7[0],
            childFlipConfig = _ref7[1];

        if (childFlipConfig.transformOrigin) {
          child.style.transformOrigin = childFlipConfig.transformOrigin;
        } else if (applyTransformOrigin) {
          child.style.transformOrigin = "0 0";
        }
      });
    };

    return utilities_assign({}, toReturn, {
      stagger: stagger,
      springConfig: springConfig,
      getOnUpdateFunc: getOnUpdateFunc,
      initializeFlip: initializeFlip,
      onAnimationEnd: onAnimationEnd
    });
  }).filter(function (x) {
    return x;
  });

  // we use this array to compare with completed animations
  // to decide when all animations are completed
  withInitFuncs = flipDataArray.filter(function (_ref8) {
    var initializeFlip = _ref8.initializeFlip;
    return Boolean(initializeFlip);
  });
  //  put items back in place
  withInitFuncs.forEach(function (_ref9) {
    var initializeFlip = _ref9.initializeFlip;
    return initializeFlip();
  });

  if (debug) return;

  var flipDict = flipDataArray.reduce(function (acc, curr) {
    acc[curr.id] = curr;
    return acc;
  }, {});

  // this function modifies flipDataArray in-place
  // by removing references to non-direct children
  // to enable recursive stagger

  var _filterFlipDescendant = filterFlipDescendants({
    flipDict: flipDict,
    flippedIds: flippedIds,
    scopedSelector: scopedSelector
  }),
      topLevelChildren = _filterFlipDescendant.topLevelChildren;

  return function () {
    // there are no active FLIP animations, so immediately resolve the
    // returned promise
    if (!withInitFuncs.length) closureResolve();
    initiateAnimations({ topLevelChildren: topLevelChildren, flipDict: flipDict, staggerConfig: staggerConfig });
    return flipCompletedPromise;
  };
};

/* harmony default export */ var flip_animateFlippedElements = (animateFlippedElements_animateFlippedElements);
// CONCATENATED MODULE: ./src/flip/getFlippedElementPositions/index.js



var getFlippedElementPositions_cancelInProgressAnimations = function cancelInProgressAnimations(inProgressAnimations) {
  Object.keys(inProgressAnimations).forEach(function (id) {
    if (inProgressAnimations[id].stop) inProgressAnimations[id].stop();
    delete inProgressAnimations[id];
  });
};

var getFlippedElementPositions_addTupleToObject = function addTupleToObject(acc, curr) {
  var _assign;

  return utilities_assign(acc, (_assign = {}, _assign[curr[0]] = curr[1], _assign));
};

var getFlippedElementPositions_getAllElements = function getAllElements(element, portalKey) {
  if (portalKey) {
    return toArray(document.querySelectorAll("[" + DATA_PORTAL_KEY + "=\"" + portalKey + "\"]"));
  } else {
    return toArray(element.querySelectorAll("[" + DATA_FLIP_ID + "]"));
  }
};

/**
 * Called in getSnapshotBeforeUpdate in the Flipped Component
 * @param {Object} args
 * @param {HTMLElement} args.element - the ref for the parent Flipper component
 * @param {Object} args.flipCallbacks - passed in solely to identify which
 * elements have onExit callbacks, and cache their dom elements appropriately
 * @param {Object} args.inProgressAnimations - stop callbacks for currently in
 * progress animations
 * @returns {Object} flippedElementPositions
 */
var getFlippedElementPositions_getFlippedElementPositionsBeforeUpdate = function getFlippedElementPositionsBeforeUpdate(_ref) {
  var element = _ref.element,
      _ref$flipCallbacks = _ref.flipCallbacks,
      flipCallbacks = _ref$flipCallbacks === undefined ? {} : _ref$flipCallbacks,
      _ref$inProgressAnimat = _ref.inProgressAnimations,
      inProgressAnimations = _ref$inProgressAnimat === undefined ? {} : _ref$inProgressAnimat,
      portalKey = _ref.portalKey;

  var flippedElements = getFlippedElementPositions_getAllElements(element, portalKey);

  var inverseFlippedElements = toArray(element.querySelectorAll("[" + DATA_INVERSE_FLIP_ID + "]"));

  var childIdsToParentBCRs = {};
  var parentBCRs = [];
  var childIdsToParents = {};
  // this is for exit animations so we can re-insert exiting elements in the
  // DOM later
  flippedElements.filter(function (el) {
    return flipCallbacks && flipCallbacks[el.dataset.flipId] && flipCallbacks[el.dataset.flipId].onExit;
  }).forEach(function (el) {
    var parent = el.parentNode;
    // this won't work for IE11
    if (el.closest) {
      var exitContainer = el.closest("[" + DATA_EXIT_CONTAINER + "]");
      if (exitContainer) parent = exitContainer;
    }
    var bcrIndex = parentBCRs.findIndex(function (n) {
      return n[0] === parent;
    });
    if (bcrIndex === -1) {
      parentBCRs.push([parent, parent.getBoundingClientRect()]);
      bcrIndex = parentBCRs.length - 1;
    }
    childIdsToParentBCRs[el.dataset.flipId] = parentBCRs[bcrIndex][1];
    childIdsToParents[el.dataset.flipId] = parent;
  });

  var flippedElementPositions = flippedElements.map(function (child) {
    var domData = {};
    var childBCR = child.getBoundingClientRect();

    // only cache extra data for exit animations
    // if the element has an onExit listener
    if (flipCallbacks && flipCallbacks[child.dataset.flipId] && flipCallbacks[child.dataset.flipId].onExit) {
      var parentBCR = childIdsToParentBCRs[child.dataset.flipId];

      utilities_assign(domData, {
        element: child,
        parent: childIdsToParents[child.dataset.flipId],
        childPosition: {
          top: childBCR.top - parentBCR.top,
          left: childBCR.left - parentBCR.left,
          width: childBCR.width,
          height: childBCR.height
        }
      });
    }

    return [child.dataset.flipId, {
      rect: childBCR,
      opacity: parseFloat(window.getComputedStyle(child).opacity),
      domData: domData
    }];
  }).reduce(getFlippedElementPositions_addTupleToObject, {});

  // do this at the very end since we want to cache positions of elements
  // while they are mid-transition
  getFlippedElementPositions_cancelInProgressAnimations(inProgressAnimations);

  flippedElements.concat(inverseFlippedElements).forEach(function (el) {
    el.style.transform = "";
    el.style.opacity = "";
  });
  return {
    flippedElementPositions: flippedElementPositions,
    cachedOrderedFlipIds: flippedElements.map(function (el) {
      return el.dataset.flipId;
    })
  };
};

/**
 * This function is called in onFlipKeyUpdate
 * (which is called in the Flipper component's componentDidUpdate)
 * @param {HTMLElement} args.element - the ref for the parent Flipper component
 * @returns {Object} flippedElementPositions
 */
var getFlippedElementPositions_getFlippedElementPositionsAfterUpdate = function getFlippedElementPositionsAfterUpdate(_ref2) {
  var element = _ref2.element,
      portalKey = _ref2.portalKey;

  return getFlippedElementPositions_getAllElements(element, portalKey).map(function (child) {
    var computedStyle = window.getComputedStyle(child);
    var rect = child.getBoundingClientRect();
    return [child.dataset.flipId, {
      rect: rect,
      opacity: parseFloat(computedStyle.opacity),
      domData: {},
      transform: computedStyle.transform
    }];
  }).reduce(getFlippedElementPositions_addTupleToObject, {});
};
// CONCATENATED MODULE: ./src/flip/index.js






var flip_createScopedSelector = function createScopedSelector(element, portalKey) {
  if (portalKey) {
    return function (selector) {
      return document.querySelectorAll("[" + DATA_PORTAL_KEY + "=" + portalKey + "]" + selector);
    };
  } else {
    return function (selector) {
      return element.querySelectorAll(selector);
    };
  }
};

var flip_createGetElementFunc = function createGetElementFunc(element, portalKey) {
  // this should only ever return 1 element
  return function (id) {
    return flip_createScopedSelector(element, portalKey)("[" + DATA_FLIP_ID + "=\"" + id + "\"]")[0];
  };
};

var flip_onFlipKeyUpdate = function onFlipKeyUpdate(_ref) {
  var _ref$cachedOrderedFli = _ref.cachedOrderedFlipIds,
      cachedOrderedFlipIds = _ref$cachedOrderedFli === undefined ? [] : _ref$cachedOrderedFli,
      _ref$inProgressAnimat = _ref.inProgressAnimations,
      inProgressAnimations = _ref$inProgressAnimat === undefined ? {} : _ref$inProgressAnimat,
      _ref$cachedFlipChildr = _ref.cachedFlipChildrenPositions,
      cachedFlipChildrenPositions = _ref$cachedFlipChildr === undefined ? {} : _ref$cachedFlipChildr,
      _ref$flipCallbacks = _ref.flipCallbacks,
      flipCallbacks = _ref$flipCallbacks === undefined ? {} : _ref$flipCallbacks,
      containerEl = _ref.containerEl,
      applyTransformOrigin = _ref.applyTransformOrigin,
      spring = _ref.spring,
      debug = _ref.debug,
      portalKey = _ref.portalKey,
      _ref$staggerConfig = _ref.staggerConfig,
      staggerConfig = _ref$staggerConfig === undefined ? {} : _ref$staggerConfig,
      _ref$decisionData = _ref.decisionData,
      decisionData = _ref$decisionData === undefined ? {} : _ref$decisionData,
      handleEnterUpdateDelete = _ref.handleEnterUpdateDelete;

  var newFlipChildrenPositions = getFlippedElementPositions_getFlippedElementPositionsAfterUpdate({
    element: containerEl,
    portalKey: portalKey
  });

  var scopedSelector = flip_createScopedSelector(containerEl, portalKey);
  var getElement = flip_createGetElementFunc(containerEl, portalKey);

  var isFlipped = function isFlipped(id) {
    return cachedFlipChildrenPositions[id] && newFlipChildrenPositions[id];
  };

  var unflippedIds = Object.keys(cachedFlipChildrenPositions).concat(Object.keys(newFlipChildrenPositions)).filter(function (id) {
    return !isFlipped(id);
  });

  var baseArgs = {
    flipCallbacks: flipCallbacks,
    getElement: getElement,
    cachedFlipChildrenPositions: cachedFlipChildrenPositions,
    newFlipChildrenPositions: newFlipChildrenPositions,
    inProgressAnimations: inProgressAnimations
  };

  var _animateUnflippedElem = flip_animateUnflippedElements(utilities_assign({}, baseArgs, {
    unflippedIds: unflippedIds
  })),
      hideEnteringElements = _animateUnflippedElem.hideEnteringElements,
      animateEnteringElements = _animateUnflippedElem.animateEnteringElements,
      animateExitingElements = _animateUnflippedElem.animateExitingElements;

  var flippedIds = cachedOrderedFlipIds.filter(isFlipped);
  var animateFlippedElementsArgs = utilities_assign({}, baseArgs, {
    flippedIds: flippedIds,
    applyTransformOrigin: applyTransformOrigin,
    spring: spring,
    debug: debug,
    staggerConfig: staggerConfig,
    decisionData: decisionData,
    scopedSelector: scopedSelector
  });

  // the function handles putting flipped elements back in their original positions
  // and returns another function to actually call flip
  var flip = flip_animateFlippedElements(animateFlippedElementsArgs);

  if (handleEnterUpdateDelete) {
    handleEnterUpdateDelete({
      hideEnteringElements: hideEnteringElements,
      animateEnteringElements: animateEnteringElements,
      animateExitingElements: animateExitingElements,
      animateFlippedElements: flip
    });
  } else {
    hideEnteringElements();
    animateExitingElements().then(animateEnteringElements);
    flip();
  }
};

/* harmony default export */ var src_flip = (flip_onFlipKeyUpdate);
// CONCATENATED MODULE: ./src/Flipper.js
function Flipper_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Flipper_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Flipper_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }






var Flipper_FlipContext = Object(external_root_React_commonjs2_react_commonjs_react_amd_react_["createContext"])("flip");
var Flipper_PortalContext = Object(external_root_React_commonjs2_react_commonjs_react_amd_react_["createContext"])("portal");

var Flipper_Flipper = function (_Component) {
  Flipper_inherits(Flipper, _Component);

  function Flipper(props) {
    Flipper_classCallCheck(this, Flipper);

    var _this = Flipper_possibleConstructorReturn(this, _Component.call(this, props));

    _this.inProgressAnimations = {};
    _this.flipCallbacks = {};
    return _this;
  }

  Flipper.prototype.getSnapshotBeforeUpdate = function getSnapshotBeforeUpdate(prevProps) {
    if (prevProps.flipKey !== this.props.flipKey) {
      return getFlippedElementPositions_getFlippedElementPositionsBeforeUpdate({
        element: this.el,
        // if onExit callbacks exist here, we'll cache the DOM node
        flipCallbacks: this.flipCallbacks,
        inProgressAnimations: this.inProgressAnimations,
        portalKey: this.props.portalKey
      });
    }
    return null;
  };

  Flipper.prototype.componentDidUpdate = function componentDidUpdate(prevProps, prevState, cachedData) {
    if (this.props.flipKey !== prevProps.flipKey) {
      src_flip({
        cachedFlipChildrenPositions: cachedData.flippedElementPositions,
        cachedOrderedFlipIds: cachedData.cachedOrderedFlipIds,
        containerEl: this.el,
        inProgressAnimations: this.inProgressAnimations,
        flipCallbacks: this.flipCallbacks,
        applyTransformOrigin: this.props.applyTransformOrigin,
        spring: this.props.spring,
        debug: this.props.debug,
        portalKey: this.props.portalKey,
        staggerConfig: this.props.staggerConfig,
        handleEnterUpdateDelete: this.props.handleEnterUpdateDelete,
        decisionData: {
          prev: prevProps.decisionData,
          current: this.props.decisionData
        }
      });
    }
  };

  Flipper.prototype.render = function render() {
    var _this2 = this;

    var _props = this.props,
        element = _props.element,
        className = _props.className,
        portalKey = _props.portalKey;

    var Element = element;

    return external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.createElement(
      Flipper_PortalContext.Provider,
      { value: portalKey },
      external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.createElement(
        Flipper_FlipContext.Provider,
        { value: this.flipCallbacks },
        external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.createElement(
          Element,
          { className: className, ref: function ref(el) {
              return _this2.el = el;
            } },
          this.props.children
        )
      )
    );
  };

  return Flipper;
}(external_root_React_commonjs2_react_commonjs_react_amd_react_["Component"]);

Flipper_Flipper.propTypes = {
  flipKey: prop_types_default.a.any,
  children: prop_types_default.a.node.isRequired,
  spring: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.object]),
  applyTransformOrigin: prop_types_default.a.bool,
  debug: prop_types_default.a.bool,
  element: prop_types_default.a.string,
  className: prop_types_default.a.string,
  portalKey: prop_types_default.a.string,
  staggerConfig: prop_types_default.a.object,
  decisionData: prop_types_default.a.any,
  handleEnterUpdateDelete: prop_types_default.a.func
};

Flipper_Flipper.defaultProps = {
  applyTransformOrigin: true,
  element: "div"
};

/* harmony default export */ var src_Flipper = (Flipper_Flipper);
// CONCATENATED MODULE: ./src/Flipped.js
var Flipped_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function Flipped_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function Flipped_possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function Flipped_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function Flipped_objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }







var Flipped_customPropCheck = function customPropCheck(props, propName) {
  if (props.flipId && props.inverseFlipId) {
    return new Error('Please only provide one of the two: "FlipId" or "inverseFlipID"');
  } else if (props.flipId === undefined && props.inverseFlipId === undefined) {
    return new Error("Must provide either a \"FlipId\" or an \"InverseFlipId\" prop");
  } else if (props[propName] && typeof props[propName] !== "string") {
    return new Error(propName + " must be a string");
  }
};

var Flipped_propTypes = {
  children: prop_types_default.a.node.isRequired,
  inverseFlipId: Flipped_customPropCheck,
  flipId: Flipped_customPropCheck,
  opacity: prop_types_default.a.bool,
  translate: prop_types_default.a.bool,
  scale: prop_types_default.a.bool,
  transformOrigin: prop_types_default.a.string,
  spring: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.object]),
  onStart: prop_types_default.a.func,
  onComplete: prop_types_default.a.func,
  onAppear: prop_types_default.a.func,
  shouldFlip: prop_types_default.a.func,
  shouldInvert: prop_types_default.a.func,
  onExit: prop_types_default.a.func,
  portalKey: prop_types_default.a.string,
  stagger: prop_types_default.a.oneOfType([prop_types_default.a.string, prop_types_default.a.bool])
  // This wrapper creates child components for the main Flipper component
};function Flipped_Flipped(_ref) {
  var _dataAttributes;

  var children = _ref.children,
      flipId = _ref.flipId,
      inverseFlipId = _ref.inverseFlipId,
      portalKey = _ref.portalKey,
      rest = Flipped_objectWithoutProperties(_ref, ["children", "flipId", "inverseFlipId", "portalKey"]);

  var child = void 0;
  try {
    child = external_root_React_commonjs2_react_commonjs_react_amd_react_["Children"].only(children);
  } catch (e) {
    throw new Error("Each Flipped component must wrap a single child");
  }
  // if nothing is being animated, assume everything is being animated
  if (!rest.scale && !rest.translate && !rest.opacity) {
    utilities_assign(rest, {
      translate: true,
      scale: true,
      opacity: true
    });
  }

  var dataAttributes = (_dataAttributes = {}, _dataAttributes[DATA_FLIP_ID] = flipId, _dataAttributes[DATA_INVERSE_FLIP_ID] = inverseFlipId, _dataAttributes[DATA_FLIP_CONFIG] = JSON.stringify(rest), _dataAttributes);

  if (portalKey) {
    dataAttributes[DATA_PORTAL_KEY] = portalKey;
  }

  return Object(external_root_React_commonjs2_react_commonjs_react_amd_react_["cloneElement"])(child, dataAttributes);
}

var Flipped_FlippedWithContext = function (_Component) {
  Flipped_inherits(FlippedWithContext, _Component);

  function FlippedWithContext() {
    Flipped_classCallCheck(this, FlippedWithContext);

    return Flipped_possibleConstructorReturn(this, _Component.apply(this, arguments));
  }

  FlippedWithContext.prototype.render = function render() {
    var _props = this.props,
        children = _props.children,
        flipId = _props.flipId,
        shouldFlip = _props.shouldFlip,
        shouldInvert = _props.shouldInvert,
        onAppear = _props.onAppear,
        onStart = _props.onStart,
        onComplete = _props.onComplete,
        onExit = _props.onExit,
        rest = Flipped_objectWithoutProperties(_props, ["children", "flipId", "shouldFlip", "shouldInvert", "onAppear", "onStart", "onComplete", "onExit"]);

    if (rest.inverseFlipId) return external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.createElement(
      Flipped_Flipped,
      rest,
      children
    );
    return external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.createElement(
      Flipper_PortalContext.Consumer,
      null,
      function (portalKey) {
        return external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.createElement(
          Flipper_FlipContext.Consumer,
          null,
          function (data) {
            // if there is no surrounding Flipper component,
            // we don't want to throw an error, so check
            // that data exists and is not the default string
            if (isObject(data)) {
              data[flipId] = {
                shouldFlip: shouldFlip,
                shouldInvert: shouldInvert,
                onAppear: onAppear,
                onStart: onStart,
                onComplete: onComplete,
                onExit: onExit
              };
            }
            return external_root_React_commonjs2_react_commonjs_react_amd_react_default.a.createElement(
              Flipped_Flipped,
              Flipped_extends({ flipId: flipId }, rest, { portalKey: portalKey }),
              children
            );
          }
        );
      }
    );
  };

  return FlippedWithContext;
}(external_root_React_commonjs2_react_commonjs_react_amd_react_["Component"]);

Flipped_FlippedWithContext.propTypes = Flipped_propTypes;

/* harmony default export */ var src_Flipped = (Flipped_FlippedWithContext);
// CONCATENATED MODULE: ./src/ExitContainer.js



var ExitContainer_ExitContainer = function ExitContainer(_ref) {
  var _cloneElement;

  var children = _ref.children;

  return Object(external_root_React_commonjs2_react_commonjs_react_amd_react_["cloneElement"])(children, (_cloneElement = {}, _cloneElement[DATA_EXIT_CONTAINER] = true, _cloneElement));
};

/* harmony default export */ var src_ExitContainer = (ExitContainer_ExitContainer);
// CONCATENATED MODULE: ./src/index.js
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "Flipper", function() { return src_Flipper; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "Flipped", function() { return src_Flipped; });
/* concated harmony reexport */__webpack_require__.d(__webpack_exports__, "ExitContainer", function() { return src_ExitContainer; });




// for umd build
/* harmony default export */ var src = __webpack_exports__["default"] = ({
  Flipper: src_Flipper,
  Flipped: src_Flipped,
  ExitContainer: src_ExitContainer
});





/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */



var ReactPropTypesSecret = __webpack_require__(3);

function emptyFunction() {}

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    var err = new Error(
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
    err.name = 'Invariant Violation';
    throw err;
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(2);


/***/ })
/******/ ])["default"];
});