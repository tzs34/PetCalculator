"use strict";

exports.__esModule = true;
var animateUnflippedElements = function animateUnflippedElements(_ref) {
  var unflippedIds = _ref.unflippedIds,
      flipCallbacks = _ref.flipCallbacks,
      getElement = _ref.getElement,
      newFlipChildrenPositions = _ref.newFlipChildrenPositions,
      cachedFlipChildrenPositions = _ref.cachedFlipChildrenPositions,
      inProgressAnimations = _ref.inProgressAnimations;

  var enteringElements = unflippedIds.filter(function (id) {
    return newFlipChildrenPositions[id] && flipCallbacks[id];
  });

  var exitingElementIds = unflippedIds.filter(function (id) {
    return cachedFlipChildrenPositions[id] && flipCallbacks[id] && flipCallbacks[id].onExit;
  });

  var hideEnteringElements = function hideEnteringElements() {
    enteringElements.forEach(function (id) {
      if (flipCallbacks[id] && flipCallbacks[id].onAppear) {
        var element = getElement(id);
        element.style.opacity = "0";
      }
    });
  };

  var animateEnteringElements = function animateEnteringElements() {
    enteringElements.forEach(function (id, i) {
      var element = getElement(id);
      if (flipCallbacks[id] && flipCallbacks[id].onAppear) flipCallbacks[id].onAppear(element, i);
    });
  };

  var closureResolve = void 0;

  var promiseToReturn = new Promise(function (resolve, reject) {
    closureResolve = resolve;
  });

  var fragmentTuples = [];
  var exitingElementCount = 0;

  var onExitCallbacks = exitingElementIds.map(function (id, i) {
    var _cachedFlipChildrenPo = cachedFlipChildrenPositions[id].domData,
        element = _cachedFlipChildrenPo.element,
        parent = _cachedFlipChildrenPo.parent,
        _cachedFlipChildrenPo2 = _cachedFlipChildrenPo.childPosition,
        top = _cachedFlipChildrenPo2.top,
        left = _cachedFlipChildrenPo2.left,
        width = _cachedFlipChildrenPo2.width,
        height = _cachedFlipChildrenPo2.height;
    // insert back into dom

    if (getComputedStyle(parent).position === "static") {
      parent.style.position = "relative";
    }
    element.style.transform = "matrix(1, 0, 0, 1, 0, 0)";
    element.style.position = "absolute";
    element.style.top = top + "px";
    element.style.left = left + "px";
    // taken out of the dom flow, the element might have lost these dimensions
    element.style.height = height + "px";
    element.style.width = width + "px";
    var fragmentTuple = fragmentTuples.filter(function (t) {
      return t[0] === parent;
    })[0];
    if (!fragmentTuple) {
      fragmentTuple = [parent, document.createDocumentFragment()];
      fragmentTuples.push(fragmentTuple);
    }
    fragmentTuple[1].appendChild(element);

    exitingElementCount += 1;

    var stop = function stop() {
      try {
        parent.removeChild(element);
        exitingElementCount -= 1;
        if (exitingElementCount === 0) closureResolve();
      } catch (DOMException) {
        // the element is already gone
      }
    };
    inProgressAnimations[id] = { stop: stop };
    return function () {
      return flipCallbacks[id].onExit(element, i, stop);
    };
  });

  // now append all the fragments from the onExit callbacks
  // (we use fragments for performance)
  fragmentTuples.forEach(function (t) {
    var parent = t[0];
    var fragment = t[1];
    parent.appendChild(fragment);
  });

  if (!onExitCallbacks.length) closureResolve();

  var animateExitingElements = function animateExitingElements() {
    onExitCallbacks.forEach(function (c) {
      return c();
    });
    return promiseToReturn;
  };

  return {
    hideEnteringElements: hideEnteringElements,
    animateEnteringElements: animateEnteringElements,
    animateExitingElements: animateExitingElements
  };
};

exports.default = animateUnflippedElements;
module.exports = exports["default"];