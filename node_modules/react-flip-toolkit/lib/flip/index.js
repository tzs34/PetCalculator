"use strict";

exports.__esModule = true;

var _animateUnflippedElements = require("./animateUnflippedElements");

var _animateUnflippedElements2 = _interopRequireDefault(_animateUnflippedElements);

var _animateFlippedElements = require("./animateFlippedElements");

var _animateFlippedElements2 = _interopRequireDefault(_animateFlippedElements);

var _getFlippedElementPositions = require("./getFlippedElementPositions");

var _constants = require("../constants");

var constants = _interopRequireWildcard(_constants);

var _utilities = require("../utilities");

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var createScopedSelector = function createScopedSelector(element, portalKey) {
  if (portalKey) {
    return function (selector) {
      return document.querySelectorAll("[" + constants.DATA_PORTAL_KEY + "=" + portalKey + "]" + selector);
    };
  } else {
    return function (selector) {
      return element.querySelectorAll(selector);
    };
  }
};

var createGetElementFunc = function createGetElementFunc(element, portalKey) {
  // this should only ever return 1 element
  return function (id) {
    return createScopedSelector(element, portalKey)("[" + constants.DATA_FLIP_ID + "=\"" + id + "\"]")[0];
  };
};

var onFlipKeyUpdate = function onFlipKeyUpdate(_ref) {
  var _ref$cachedOrderedFli = _ref.cachedOrderedFlipIds,
      cachedOrderedFlipIds = _ref$cachedOrderedFli === undefined ? [] : _ref$cachedOrderedFli,
      _ref$inProgressAnimat = _ref.inProgressAnimations,
      inProgressAnimations = _ref$inProgressAnimat === undefined ? {} : _ref$inProgressAnimat,
      _ref$cachedFlipChildr = _ref.cachedFlipChildrenPositions,
      cachedFlipChildrenPositions = _ref$cachedFlipChildr === undefined ? {} : _ref$cachedFlipChildr,
      _ref$flipCallbacks = _ref.flipCallbacks,
      flipCallbacks = _ref$flipCallbacks === undefined ? {} : _ref$flipCallbacks,
      containerEl = _ref.containerEl,
      applyTransformOrigin = _ref.applyTransformOrigin,
      spring = _ref.spring,
      debug = _ref.debug,
      portalKey = _ref.portalKey,
      _ref$staggerConfig = _ref.staggerConfig,
      staggerConfig = _ref$staggerConfig === undefined ? {} : _ref$staggerConfig,
      _ref$decisionData = _ref.decisionData,
      decisionData = _ref$decisionData === undefined ? {} : _ref$decisionData,
      handleEnterUpdateDelete = _ref.handleEnterUpdateDelete;

  var newFlipChildrenPositions = (0, _getFlippedElementPositions.getFlippedElementPositionsAfterUpdate)({
    element: containerEl,
    portalKey: portalKey
  });

  var scopedSelector = createScopedSelector(containerEl, portalKey);
  var getElement = createGetElementFunc(containerEl, portalKey);

  var isFlipped = function isFlipped(id) {
    return cachedFlipChildrenPositions[id] && newFlipChildrenPositions[id];
  };

  var unflippedIds = Object.keys(cachedFlipChildrenPositions).concat(Object.keys(newFlipChildrenPositions)).filter(function (id) {
    return !isFlipped(id);
  });

  var baseArgs = {
    flipCallbacks: flipCallbacks,
    getElement: getElement,
    cachedFlipChildrenPositions: cachedFlipChildrenPositions,
    newFlipChildrenPositions: newFlipChildrenPositions,
    inProgressAnimations: inProgressAnimations
  };

  var _animateUnflippedElem = (0, _animateUnflippedElements2.default)((0, _utilities.assign)({}, baseArgs, {
    unflippedIds: unflippedIds
  })),
      hideEnteringElements = _animateUnflippedElem.hideEnteringElements,
      animateEnteringElements = _animateUnflippedElem.animateEnteringElements,
      animateExitingElements = _animateUnflippedElem.animateExitingElements;

  var flippedIds = cachedOrderedFlipIds.filter(isFlipped);
  var animateFlippedElementsArgs = (0, _utilities.assign)({}, baseArgs, {
    flippedIds: flippedIds,
    applyTransformOrigin: applyTransformOrigin,
    spring: spring,
    debug: debug,
    staggerConfig: staggerConfig,
    decisionData: decisionData,
    scopedSelector: scopedSelector
  });

  // the function handles putting flipped elements back in their original positions
  // and returns another function to actually call flip
  var flip = (0, _animateFlippedElements2.default)(animateFlippedElementsArgs);

  if (handleEnterUpdateDelete) {
    handleEnterUpdateDelete({
      hideEnteringElements: hideEnteringElements,
      animateEnteringElements: animateEnteringElements,
      animateExitingElements: animateExitingElements,
      animateFlippedElements: flip
    });
  } else {
    hideEnteringElements();
    animateExitingElements().then(animateEnteringElements);
    flip();
  }
};

exports.default = onFlipKeyUpdate;
module.exports = exports["default"];