"use strict";

exports.__esModule = true;
exports.staggeredSprings = exports.createSpring = exports.createSuspendedSpring = undefined;

var _forkedRebound = require("../../forked-rebound");

// this should get created only 1x
var springSystem = new _forkedRebound.SpringSystem();

var createSuspendedSpring = exports.createSuspendedSpring = function createSuspendedSpring(_ref) {
  var _ref$springConfig = _ref.springConfig,
      stiffness = _ref$springConfig.stiffness,
      damping = _ref$springConfig.damping,
      overshootClamping = _ref$springConfig.overshootClamping,
      noOp = _ref.noOp,
      onSpringActivate = _ref.onSpringActivate,
      getOnUpdateFunc = _ref.getOnUpdateFunc,
      onAnimationEnd = _ref.onAnimationEnd;

  if (noOp) return;
  var spring = springSystem.createSpring(stiffness, damping);
  spring.setOvershootClampingEnabled(!!overshootClamping);
  spring.addListener({
    onSpringActivate: onSpringActivate,
    onSpringUpdate: getOnUpdateFunc(spring.destroy.bind(spring)),
    onSpringAtRest: function onSpringAtRest() {
      // prevent SpringSystem from caching unused springs
      spring.destroy();
      onAnimationEnd();
    }
  });
  return spring;
};

var createSpring = exports.createSpring = function createSpring(flipped) {
  var spring = createSuspendedSpring(flipped);
  if (spring) spring.setEndValue(1);else {
    // even if it was a noop,
    // we still need to call onSpringActivate in case it calls
    // cascading flip initiation functions
    flipped.onSpringActivate();
  }
};

var staggeredSprings = exports.staggeredSprings = function staggeredSprings(flippedArray) {
  var staggerConfig = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (!flippedArray || !flippedArray.length) return;

  if (staggerConfig.reverse) flippedArray.reverse();

  var normalizedSpeed = staggerConfig.speed ? 1 + Math.max(Math.min(staggerConfig.speed, 0), 1) : 1.1;

  var nextThreshold = 1 / Math.max(Math.min(flippedArray.length, 100), 10);

  var springFuncs = flippedArray.filter(function (flipped) {
    return !flipped.noOp;
  }).map(function (flipped, i) {
    var cachedGetOnUpdate = flipped.getOnUpdateFunc;

    // modify the update function to adjust
    // the end value of the trailing Flipped component
    flipped.getOnUpdateFunc = function (stop) {
      var onUpdate = cachedGetOnUpdate(stop);
      return function (spring) {
        var currentValue = spring.getCurrentValue();
        if (currentValue > nextThreshold) {
          springFuncs[i + 1] && springFuncs[i + 1].setEndValue(Math.min(currentValue * normalizedSpeed, 1));
        }
        // now call the actual update function
        onUpdate(spring);
      };
    };
    return flipped;
  }).map(function (flipped) {
    return createSuspendedSpring(flipped);
  });

  springFuncs[0] && springFuncs[0].setEndValue(1);
};