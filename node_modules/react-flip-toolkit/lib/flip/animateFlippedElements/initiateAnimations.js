"use strict";

exports.__esModule = true;
exports.createCallTree = undefined;

var _spring = require("./spring");

var initiateImmediateAnimations = function initiateImmediateAnimations(immediate) {
  if (!immediate) return;
  immediate.forEach(function (flipped) {
    (0, _spring.createSpring)(flipped);
    initiateImmediateAnimations(flipped.immediate);
  });
};

var createCallTree = exports.createCallTree = function createCallTree(_ref) {
  var flipDict = _ref.flipDict,
      topLevelChildren = _ref.topLevelChildren,
      initiateStaggeredAnimations = _ref.initiateStaggeredAnimations;

  //build a data struct to run the springs
  var tree = {
    root: {
      staggeredChildren: {},
      immediateChildren: []
    }

    // helper function to build the nested structure
  };var appendChild = function appendChild(parent, childId) {
    var flipData = flipDict[childId];
    // might have been filtered (e.g. because it was off screen)
    if (!flipData) return;

    if (flipData.stagger) {
      parent.staggeredChildren[flipData.stagger] ? parent.staggeredChildren[flipData.stagger].push(flipData) : parent.staggeredChildren[flipData.stagger] = [flipData];
    } else parent.immediateChildren.push(flipData);

    // only when the spring is first activated, activate the child animations as well
    // this enables nested stagger
    flipData.onSpringActivate = function () {
      initiateImmediateAnimations(flipData.immediateChildren);
      initiateStaggeredAnimations(flipData.staggeredChildren);
    };

    flipData.staggeredChildren = {};
    flipData.immediateChildren = [];

    flipData.childIds.forEach(function (childId) {
      return appendChild(flipData, childId);
    });
  };

  // create the nested structure
  topLevelChildren.forEach(function (c) {
    appendChild(tree.root, c);
  });

  return tree;
};

exports.default = function (_ref2) {
  var staggerConfig = _ref2.staggerConfig,
      flipDict = _ref2.flipDict,
      topLevelChildren = _ref2.topLevelChildren;

  var initiateStaggeredAnimations = function initiateStaggeredAnimations(staggered) {
    if (!staggered || !Object.keys(staggered).length) return;
    Object.keys(staggered).forEach(function (staggerKey) {
      return (0, _spring.staggeredSprings)(staggered[staggerKey], staggerConfig[staggerKey]);
    });
  };

  var tree = createCallTree({
    flipDict: flipDict,
    topLevelChildren: topLevelChildren,
    initiateStaggeredAnimations: initiateStaggeredAnimations
  });

  initiateImmediateAnimations(tree.root.immediateChildren);
  initiateStaggeredAnimations(tree.root.staggeredChildren);
};