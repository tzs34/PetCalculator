"use strict";

exports.__esModule = true;
exports.getFlippedElementPositionsAfterUpdate = exports.getFlippedElementPositionsBeforeUpdate = exports.getAllElements = undefined;

var _utilities = require("../../utilities");

var _constants = require("../../constants");

var constants = _interopRequireWildcard(_constants);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

var cancelInProgressAnimations = function cancelInProgressAnimations(inProgressAnimations) {
  Object.keys(inProgressAnimations).forEach(function (id) {
    if (inProgressAnimations[id].stop) inProgressAnimations[id].stop();
    delete inProgressAnimations[id];
  });
};

var addTupleToObject = function addTupleToObject(acc, curr) {
  var _assign;

  return (0, _utilities.assign)(acc, (_assign = {}, _assign[curr[0]] = curr[1], _assign));
};

var getAllElements = exports.getAllElements = function getAllElements(element, portalKey) {
  if (portalKey) {
    return (0, _utilities.toArray)(document.querySelectorAll("[" + constants.DATA_PORTAL_KEY + "=\"" + portalKey + "\"]"));
  } else {
    return (0, _utilities.toArray)(element.querySelectorAll("[" + constants.DATA_FLIP_ID + "]"));
  }
};

/**
 * Called in getSnapshotBeforeUpdate in the Flipped Component
 * @param {Object} args
 * @param {HTMLElement} args.element - the ref for the parent Flipper component
 * @param {Object} args.flipCallbacks - passed in solely to identify which
 * elements have onExit callbacks, and cache their dom elements appropriately
 * @param {Object} args.inProgressAnimations - stop callbacks for currently in
 * progress animations
 * @returns {Object} flippedElementPositions
 */
var getFlippedElementPositionsBeforeUpdate = exports.getFlippedElementPositionsBeforeUpdate = function getFlippedElementPositionsBeforeUpdate(_ref) {
  var element = _ref.element,
      _ref$flipCallbacks = _ref.flipCallbacks,
      flipCallbacks = _ref$flipCallbacks === undefined ? {} : _ref$flipCallbacks,
      _ref$inProgressAnimat = _ref.inProgressAnimations,
      inProgressAnimations = _ref$inProgressAnimat === undefined ? {} : _ref$inProgressAnimat,
      portalKey = _ref.portalKey;

  var flippedElements = getAllElements(element, portalKey);

  var inverseFlippedElements = (0, _utilities.toArray)(element.querySelectorAll("[" + constants.DATA_INVERSE_FLIP_ID + "]"));

  var childIdsToParentBCRs = {};
  var parentBCRs = [];
  var childIdsToParents = {};
  // this is for exit animations so we can re-insert exiting elements in the
  // DOM later
  flippedElements.filter(function (el) {
    return flipCallbacks && flipCallbacks[el.dataset.flipId] && flipCallbacks[el.dataset.flipId].onExit;
  }).forEach(function (el) {
    var parent = el.parentNode;
    // this won't work for IE11
    if (el.closest) {
      var exitContainer = el.closest("[" + constants.DATA_EXIT_CONTAINER + "]");
      if (exitContainer) parent = exitContainer;
    }
    var bcrIndex = parentBCRs.findIndex(function (n) {
      return n[0] === parent;
    });
    if (bcrIndex === -1) {
      parentBCRs.push([parent, parent.getBoundingClientRect()]);
      bcrIndex = parentBCRs.length - 1;
    }
    childIdsToParentBCRs[el.dataset.flipId] = parentBCRs[bcrIndex][1];
    childIdsToParents[el.dataset.flipId] = parent;
  });

  var flippedElementPositions = flippedElements.map(function (child) {
    var domData = {};
    var childBCR = child.getBoundingClientRect();

    // only cache extra data for exit animations
    // if the element has an onExit listener
    if (flipCallbacks && flipCallbacks[child.dataset.flipId] && flipCallbacks[child.dataset.flipId].onExit) {
      var parentBCR = childIdsToParentBCRs[child.dataset.flipId];

      (0, _utilities.assign)(domData, {
        element: child,
        parent: childIdsToParents[child.dataset.flipId],
        childPosition: {
          top: childBCR.top - parentBCR.top,
          left: childBCR.left - parentBCR.left,
          width: childBCR.width,
          height: childBCR.height
        }
      });
    }

    return [child.dataset.flipId, {
      rect: childBCR,
      opacity: parseFloat(window.getComputedStyle(child).opacity),
      domData: domData
    }];
  }).reduce(addTupleToObject, {});

  // do this at the very end since we want to cache positions of elements
  // while they are mid-transition
  cancelInProgressAnimations(inProgressAnimations);

  flippedElements.concat(inverseFlippedElements).forEach(function (el) {
    el.style.transform = "";
    el.style.opacity = "";
  });
  return {
    flippedElementPositions: flippedElementPositions,
    cachedOrderedFlipIds: flippedElements.map(function (el) {
      return el.dataset.flipId;
    })
  };
};

/**
 * This function is called in onFlipKeyUpdate
 * (which is called in the Flipper component's componentDidUpdate)
 * @param {HTMLElement} args.element - the ref for the parent Flipper component
 * @returns {Object} flippedElementPositions
 */
var getFlippedElementPositionsAfterUpdate = exports.getFlippedElementPositionsAfterUpdate = function getFlippedElementPositionsAfterUpdate(_ref2) {
  var element = _ref2.element,
      portalKey = _ref2.portalKey;

  return getAllElements(element, portalKey).map(function (child) {
    var computedStyle = window.getComputedStyle(child);
    var rect = child.getBoundingClientRect();
    return [child.dataset.flipId, {
      rect: rect,
      opacity: parseFloat(computedStyle.opacity),
      domData: {},
      transform: computedStyle.transform
    }];
  }).reduce(addTupleToObject, {});
};