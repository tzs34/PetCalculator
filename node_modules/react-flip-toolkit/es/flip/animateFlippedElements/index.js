import * as Rematrix from "rematrix";
import { getSpringConfig } from "../../springSettings";
import { toArray, isFunction, isNumber, getDuplicateValsAsStrings, assign } from "../../utilities";
import * as constants from "../../constants";
import filterFlipDescendants from "./filterFlipDescendants";
import initiateAnimations from "./initiateAnimations";

// 3d transforms were causing weird issues in chrome,
// especially when opacity was also being tweened,
// so convert to a 2d matrix
export var convertMatrix3dArrayTo2dArray = function convertMatrix3dArrayTo2dArray(matrix) {
  return [0, 1, 4, 5, 12, 13].map(function (index) {
    return matrix[index];
  });
};

export var convertMatrix2dArrayToString = function convertMatrix2dArrayToString(matrix) {
  return "matrix(" + matrix.join(", ") + ")";
};

export var invertTransformsForChildren = function invertTransformsForChildren(_ref) {
  var invertedChildren = _ref.invertedChildren,
      matrix = _ref.matrix,
      body = _ref.body;

  invertedChildren.forEach(function (_ref2) {
    var child = _ref2[0],
        childFlipConfig = _ref2[1];

    if (!body.contains(child)) {
      return;
    }
    var scaleX = matrix[0];
    var scaleY = matrix[3];
    var translateX = matrix[4];
    var translateY = matrix[5];

    var inverseVals = { translateX: 0, translateY: 0, scaleX: 1, scaleY: 1 };
    var transformString = "";
    if (childFlipConfig.translate) {
      inverseVals.translateX = -translateX / scaleX;
      inverseVals.translateY = -translateY / scaleY;
      transformString += "translate(" + inverseVals.translateX + "px, " + inverseVals.translateY + "px)";
    }
    if (childFlipConfig.scale) {
      inverseVals.scaleX = 1 / scaleX;
      inverseVals.scaleY = 1 / scaleY;
      transformString += " scale(" + inverseVals.scaleX + ", " + inverseVals.scaleY + ")";
    }
    child.style.transform = transformString;
  });
};

export var createApplyStylesFunc = function createApplyStylesFunc(_ref3) {
  var element = _ref3.element,
      invertedChildren = _ref3.invertedChildren,
      body = _ref3.body;
  return function (_ref4) {
    var matrix = _ref4.matrix,
        opacity = _ref4.opacity,
        forceMinVals = _ref4.forceMinVals;

    if (isNumber(opacity)) {
      element.style.opacity = opacity;
    }

    if (forceMinVals) {
      element.style.minHeight = "1px";
      element.style.minWidth = "1px";
    }

    if (!matrix) return;
    var stringTransform = convertMatrix2dArrayToString(matrix);

    // keep a tiny, invisible rotateZ transform on the element to try to
    // prevent Chrome from pixel-snapping when scale transforms
    // are removed
    stringTransform = stringTransform === "matrix(1, 0, 0, 1, 0, 0)" ? "matrix(1, 0.0001, -0.0001, 1, 0, 0)" : stringTransform;
    element.style.transform = stringTransform;

    if (invertedChildren) {
      invertTransformsForChildren({
        invertedChildren: invertedChildren,
        matrix: matrix,
        body: body
      });
    }
  };
};

export var rectInViewport = function rectInViewport(_ref5) {
  var top = _ref5.top,
      bottom = _ref5.bottom,
      left = _ref5.left,
      right = _ref5.right;

  return top < window.innerHeight && bottom > 0 && left < window.innerWidth && right > 0;
};

var getInvertedChildren = function getInvertedChildren(element, id) {
  return toArray(element.querySelectorAll("[" + constants.DATA_INVERSE_FLIP_ID + "=\"" + id + "\"]"));
};

export var tweenProp = function tweenProp(start, end, position) {
  return start + (end - start) * position;
};

var animateFlippedElements = function animateFlippedElements(_ref6) {
  var flippedIds = _ref6.flippedIds,
      flipCallbacks = _ref6.flipCallbacks,
      inProgressAnimations = _ref6.inProgressAnimations,
      cachedFlipChildrenPositions = _ref6.cachedFlipChildrenPositions,
      newFlipChildrenPositions = _ref6.newFlipChildrenPositions,
      applyTransformOrigin = _ref6.applyTransformOrigin,
      spring = _ref6.spring,
      getElement = _ref6.getElement,
      debug = _ref6.debug,
      staggerConfig = _ref6.staggerConfig,
      decisionData = _ref6.decisionData,
      scopedSelector = _ref6.scopedSelector;

  var body = document.querySelector("body");

  // the stuff below is used so we can return a promise that resolves when all FLIP animations have
  // completed
  var closureResolve = void 0;
  var flipCompletedPromise = new Promise(function (resolve, reject) {
    closureResolve = resolve;
  });
  var withInitFuncs = void 0;
  var completedAnimationIds = [];

  if (debug) {
    // eslint-disable-next-line no-console
    console.error('[react-flip-toolkit]\nThe "debug" prop is set to true. All FLIP animations will return at the beginning of the transition.');
  }

  var duplicateFlipIds = getDuplicateValsAsStrings(flippedIds);
  if (duplicateFlipIds.length) {
    // eslint-disable-next-line no-console
    console.error("[react-flip-toolkit]\nThere are currently multiple elements with the same flipId on the page.\nThe animation will only work if each Flipped component has a unique flipId.\nDuplicate flipId" + (duplicateFlipIds.length > 1 ? "s" : "") + ": " + duplicateFlipIds.join("\n"));
  }

  var flipDataArray = flippedIds
  // take all the measurements we need
  // and return an object with animation functions + necessary data
  .map(function (id) {
    var prevRect = cachedFlipChildrenPositions[id].rect;
    var currentRect = newFlipChildrenPositions[id].rect;
    var prevOpacity = cachedFlipChildrenPositions[id].opacity;
    var currentOpacity = newFlipChildrenPositions[id].opacity;
    var needsForcedMinVals = currentRect.width < 1 || currentRect.height < 1;

    // don't animate elements outside of the user's viewport
    if (!rectInViewport(prevRect) && !rectInViewport(currentRect)) {
      return false;
    }
    // it's never going to be visible, so dont animate it
    if (prevRect.width === 0 && currentRect.width === 0 || prevRect.height === 0 && currentRect.height === 0) {
      return false;
    }

    var element = getElement(id);

    // this might happen if we are rapidly adding & removing elements(?)
    if (!element) return false;

    var flipConfig = JSON.parse(element.dataset.flipConfig);

    var springConfig = getSpringConfig({
      flipperSpring: spring,
      flippedSpring: flipConfig.spring
    });

    var stagger = flipConfig.stagger === true ? "default" : flipConfig.stagger;

    var toReturn = {
      element: element,
      id: id,
      stagger: stagger,
      springConfig: springConfig,
      noOp: true
    };

    if (flipCallbacks[id] && flipCallbacks[id].shouldFlip) {
      var elementShouldFlip = flipCallbacks[id].shouldFlip(decisionData.prev, decisionData.current);
      // this element wont be animated, but its children might be
      if (!elementShouldFlip) return toReturn;
    }

    // don't animate elements that didn't change
    // but we might want to animate children
    if (prevRect.left === currentRect.left && prevRect.top === currentRect.top && prevRect.width === currentRect.width && prevRect.height === currentRect.height && prevOpacity === currentOpacity) {
      // this element wont be animated, but its children might be
      return toReturn;
    }

    toReturn.noOp = false;

    var currentTransform = Rematrix.parse(newFlipChildrenPositions[id].transform);

    var toVals = { matrix: currentTransform };

    var fromVals = {};
    var transformsArray = [currentTransform];

    // we're only going to animate the values that the child wants animated
    if (flipConfig.translate) {
      transformsArray.push(Rematrix.translateX(prevRect.left - currentRect.left));
      transformsArray.push(Rematrix.translateY(prevRect.top - currentRect.top));
    }
    // going any smaller than 1px breaks transitions in Chrome
    if (flipConfig.scale) {
      transformsArray.push(Rematrix.scaleX(Math.max(prevRect.width, 1) / Math.max(currentRect.width, 1)));
      transformsArray.push(Rematrix.scaleY(Math.max(prevRect.height, 1) / Math.max(currentRect.height, 1)));
    }

    if (flipConfig.opacity) {
      fromVals.opacity = prevOpacity;
      toVals.opacity = currentOpacity;
    }

    var invertedChildren = [];

    if (!flipCallbacks[id] || !flipCallbacks[id].shouldInvert || flipCallbacks[id].shouldInvert(decisionData.prev, decisionData.current)) {
      invertedChildren = getInvertedChildren(element, id).map(function (c) {
        return [c, JSON.parse(c.dataset.flipConfig)];
      });
    }

    fromVals.matrix = convertMatrix3dArrayTo2dArray(transformsArray.reduce(Rematrix.multiply));

    toVals.matrix = convertMatrix3dArrayTo2dArray(toVals.matrix);

    var applyStyles = createApplyStylesFunc({
      element: element,
      invertedChildren: invertedChildren,
      body: body
    });

    var onComplete = void 0;
    if (flipCallbacks[id] && flipCallbacks[id].onComplete) {
      // must cache or else this could cause an error
      var cachedOnComplete = flipCallbacks[id].onComplete;
      onComplete = function onComplete() {
        return cachedOnComplete(element, decisionData.prev, decisionData.current);
      };
    }

    // this should be called when animation ends naturally
    // but also when it is interrupted
    // when it is called, the animation has already been cancelled
    var onAnimationEnd = function onAnimationEnd() {
      delete inProgressAnimations[id];
      isFunction(onComplete) && onComplete();
      if (needsForcedMinVals && element) {
        element.style.minHeight = "";
        element.style.minWidth = "";
      }
      completedAnimationIds.push(id);

      if (completedAnimationIds.length >= withInitFuncs.length) {
        // we can theoretically call multiple times since a promise only resolves 1x
        // but that shouldnt happen
        closureResolve();
      }
    };

    var animateOpacity = isNumber(fromVals.opacity) && fromVals.opacity !== toVals.opacity;

    var onStartCalled = false;

    var getOnUpdateFunc = function getOnUpdateFunc(stop) {
      inProgressAnimations[id] = {
        stop: stop,
        onComplete: onComplete
      };
      return function (spring) {
        //trigger the user provided onStart function
        if (!onStartCalled) {
          onStartCalled = true;
          if (flipCallbacks[id] && flipCallbacks[id].onStart) flipCallbacks[id].onStart(element, decisionData.prev, decisionData.current);
        }

        var currentValue = spring.getCurrentValue();

        if (!body.contains(element)) {
          stop();
          return;
        }

        var vals = {};

        vals.matrix = fromVals.matrix.map(function (fromVal, index) {
          return tweenProp(fromVal, toVals.matrix[index], currentValue);
        });

        if (animateOpacity) {
          vals.opacity = tweenProp(fromVals.opacity, toVals.opacity, currentValue);
        }
        applyStyles(vals);
      };
    };

    var initializeFlip = function initializeFlip() {
      // before animating, immediately apply FLIP styles to prevent flicker
      applyStyles({
        matrix: fromVals.matrix,
        opacity: animateOpacity && fromVals.opacity,
        forceMinVals: needsForcedMinVals
      });
      // and batch any other style updates if necessary
      if (flipConfig.transformOrigin) {
        element.style.transformOrigin = flipConfig.transformOrigin;
      } else if (applyTransformOrigin) {
        element.style.transformOrigin = "0 0";
      }

      invertedChildren.forEach(function (_ref7) {
        var child = _ref7[0],
            childFlipConfig = _ref7[1];

        if (childFlipConfig.transformOrigin) {
          child.style.transformOrigin = childFlipConfig.transformOrigin;
        } else if (applyTransformOrigin) {
          child.style.transformOrigin = "0 0";
        }
      });
    };

    return assign({}, toReturn, {
      stagger: stagger,
      springConfig: springConfig,
      getOnUpdateFunc: getOnUpdateFunc,
      initializeFlip: initializeFlip,
      onAnimationEnd: onAnimationEnd
    });
  }).filter(function (x) {
    return x;
  });

  // we use this array to compare with completed animations
  // to decide when all animations are completed
  withInitFuncs = flipDataArray.filter(function (_ref8) {
    var initializeFlip = _ref8.initializeFlip;
    return Boolean(initializeFlip);
  });
  //  put items back in place
  withInitFuncs.forEach(function (_ref9) {
    var initializeFlip = _ref9.initializeFlip;
    return initializeFlip();
  });

  if (debug) return;

  var flipDict = flipDataArray.reduce(function (acc, curr) {
    acc[curr.id] = curr;
    return acc;
  }, {});

  // this function modifies flipDataArray in-place
  // by removing references to non-direct children
  // to enable recursive stagger

  var _filterFlipDescendant = filterFlipDescendants({
    flipDict: flipDict,
    flippedIds: flippedIds,
    scopedSelector: scopedSelector
  }),
      topLevelChildren = _filterFlipDescendant.topLevelChildren;

  return function () {
    // there are no active FLIP animations, so immediately resolve the
    // returned promise
    if (!withInitFuncs.length) closureResolve();
    initiateAnimations({ topLevelChildren: topLevelChildren, flipDict: flipDict, staggerConfig: staggerConfig });
    return flipCompletedPromise;
  };
};

export default animateFlippedElements;