import { toArray } from "../../utilities";
import * as constants from "../../constants";

// scoped selector makes sure we're querying inside the right Flipper
// container, either internally or with the right portal key
var selectFlipChildIds = function selectFlipChildIds(scopedSelector, selector, flippedIds) {
  var childIds = toArray(scopedSelector(selector)).map(function (el) {
    return el.dataset.flipId;
  });
  // now return an array ordered by the original order in the DOM
  return flippedIds.filter(function (id) {
    return childIds.indexOf(id) > -1;
  });
};

var baseSelector = "[" + constants.DATA_FLIP_ID + "]";

export default (function (_ref) {
  var flipDict = _ref.flipDict,
      flippedIds = _ref.flippedIds,
      scopedSelector = _ref.scopedSelector;

  var levelToChildren = {};

  var buildHierarchy = function buildHierarchy(selector, level, oldResult) {
    var newSelector = selector + " " + baseSelector;
    // make sure this is scoped to the Flipper element in case there are
    // mulitiple Flipper elements on the page
    var newResult = selectFlipChildIds(scopedSelector, newSelector, flippedIds);

    var oldLevelChildren = oldResult.filter(function (id) {
      return newResult.indexOf(id) === -1;
    });
    levelToChildren[level] = oldLevelChildren;
    oldLevelChildren.forEach(function (childId) {
      if (flipDict[childId]) {
        flipDict[childId].level = level;
      }
    });

    if (newResult.length !== 0) buildHierarchy(newSelector, level + 1, newResult);
  };

  // the top level selectChildFlipIds should use the scopedSelector,
  buildHierarchy(baseSelector, 0, selectFlipChildIds(scopedSelector, baseSelector, flippedIds));

  // now make sure childIds in each flippedData contains only direct children
  // since to enable nested stagger  we want each parent to be able to kick off
  // the animations only for its direct children
  Object.keys(flipDict).forEach(function (flipId) {
    var data = flipDict[flipId];
    // scop by parent element
    data.childIds = selectFlipChildIds(function (selector) {
      return data.element.querySelectorAll(selector);
    }, baseSelector, flippedIds);

    data.childIds = data.childIds.filter(function (id) {
      return levelToChildren[data.level + 1] && levelToChildren[data.level + 1].indexOf(id) > -1;
    });
  });
  return { topLevelChildren: levelToChildren["0"] };
});