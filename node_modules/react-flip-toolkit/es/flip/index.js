import animateUnflippedElements from "./animateUnflippedElements";
import animateFlippedElements from "./animateFlippedElements";
import { getFlippedElementPositionsAfterUpdate } from "./getFlippedElementPositions";
import * as constants from "../constants";
import { assign } from "../utilities";

var createScopedSelector = function createScopedSelector(element, portalKey) {
  if (portalKey) {
    return function (selector) {
      return document.querySelectorAll("[" + constants.DATA_PORTAL_KEY + "=" + portalKey + "]" + selector);
    };
  } else {
    return function (selector) {
      return element.querySelectorAll(selector);
    };
  }
};

var createGetElementFunc = function createGetElementFunc(element, portalKey) {
  // this should only ever return 1 element
  return function (id) {
    return createScopedSelector(element, portalKey)("[" + constants.DATA_FLIP_ID + "=\"" + id + "\"]")[0];
  };
};

var onFlipKeyUpdate = function onFlipKeyUpdate(_ref) {
  var _ref$cachedOrderedFli = _ref.cachedOrderedFlipIds,
      cachedOrderedFlipIds = _ref$cachedOrderedFli === undefined ? [] : _ref$cachedOrderedFli,
      _ref$inProgressAnimat = _ref.inProgressAnimations,
      inProgressAnimations = _ref$inProgressAnimat === undefined ? {} : _ref$inProgressAnimat,
      _ref$cachedFlipChildr = _ref.cachedFlipChildrenPositions,
      cachedFlipChildrenPositions = _ref$cachedFlipChildr === undefined ? {} : _ref$cachedFlipChildr,
      _ref$flipCallbacks = _ref.flipCallbacks,
      flipCallbacks = _ref$flipCallbacks === undefined ? {} : _ref$flipCallbacks,
      containerEl = _ref.containerEl,
      applyTransformOrigin = _ref.applyTransformOrigin,
      spring = _ref.spring,
      debug = _ref.debug,
      portalKey = _ref.portalKey,
      _ref$staggerConfig = _ref.staggerConfig,
      staggerConfig = _ref$staggerConfig === undefined ? {} : _ref$staggerConfig,
      _ref$decisionData = _ref.decisionData,
      decisionData = _ref$decisionData === undefined ? {} : _ref$decisionData,
      handleEnterUpdateDelete = _ref.handleEnterUpdateDelete;

  var newFlipChildrenPositions = getFlippedElementPositionsAfterUpdate({
    element: containerEl,
    portalKey: portalKey
  });

  var scopedSelector = createScopedSelector(containerEl, portalKey);
  var getElement = createGetElementFunc(containerEl, portalKey);

  var isFlipped = function isFlipped(id) {
    return cachedFlipChildrenPositions[id] && newFlipChildrenPositions[id];
  };

  var unflippedIds = Object.keys(cachedFlipChildrenPositions).concat(Object.keys(newFlipChildrenPositions)).filter(function (id) {
    return !isFlipped(id);
  });

  var baseArgs = {
    flipCallbacks: flipCallbacks,
    getElement: getElement,
    cachedFlipChildrenPositions: cachedFlipChildrenPositions,
    newFlipChildrenPositions: newFlipChildrenPositions,
    inProgressAnimations: inProgressAnimations
  };

  var _animateUnflippedElem = animateUnflippedElements(assign({}, baseArgs, {
    unflippedIds: unflippedIds
  })),
      hideEnteringElements = _animateUnflippedElem.hideEnteringElements,
      animateEnteringElements = _animateUnflippedElem.animateEnteringElements,
      animateExitingElements = _animateUnflippedElem.animateExitingElements;

  var flippedIds = cachedOrderedFlipIds.filter(isFlipped);
  var animateFlippedElementsArgs = assign({}, baseArgs, {
    flippedIds: flippedIds,
    applyTransformOrigin: applyTransformOrigin,
    spring: spring,
    debug: debug,
    staggerConfig: staggerConfig,
    decisionData: decisionData,
    scopedSelector: scopedSelector
  });

  // the function handles putting flipped elements back in their original positions
  // and returns another function to actually call flip
  var flip = animateFlippedElements(animateFlippedElementsArgs);

  if (handleEnterUpdateDelete) {
    handleEnterUpdateDelete({
      hideEnteringElements: hideEnteringElements,
      animateEnteringElements: animateEnteringElements,
      animateExitingElements: animateExitingElements,
      animateFlippedElements: flip
    });
  } else {
    hideEnteringElements();
    animateExitingElements().then(animateEnteringElements);
    flip();
  }
};

export default onFlipKeyUpdate;